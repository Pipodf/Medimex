<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medimex - Mad Max BMX Rampage</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            filter: contrast(1.2) saturate(1.5);
        }
        
        #gameCanvas {
            border: 3px solid #ff0066;
            box-shadow: 0 0 30px #ff0066, inset 0 0 30px rgba(255, 0, 102, 0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 10px #ff0066, 0 0 20px #ff0066;
            font-weight: 900;
            letter-spacing: 2px;
        }
        
        #bombTimer {
            position: absolute;
            top: 100px;
            right: 20px;
            color: #ff0066;
            font-size: 48px;
            display: none;
            text-shadow: 0 0 30px #ff0066;
            animation: pulse 0.5s infinite;
        }
        
        #objective {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            text-shadow: 0 0 15px #00ffff;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border: 2px solid #00ffff;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0066;
            font-size: 72px;
            display: none;
            text-align: center;
            text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-align: center;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #audioControls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 14px;
        }
        
        #audioControls button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 5px #00ffff;
            margin-left: 10px;
        }
        
        #audioControls button:hover {
            background: rgba(0, 255, 255, 0.4);
        }
        
        #debugInfo {
            position: absolute;
            bottom: 50px;
            left: 20px;
            color: #ffffff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border: 1px solid #ffffff;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div style="font-size: 24px;">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div>PONTOS: <span id="score">0</span></div>
            <div style="font-size: 14px; margin-top: 20px; color: #00ffff;">
                COMBO: x<span id="combo">1</span>
            </div>
        </div>
        <div id="objective">OBJETIVO: ENCONTRE O LOCAL DA BOMBA</div>
        <div id="bombTimer">‚è±Ô∏è <span id="timerValue">30</span></div>
        <div id="gameOver">
            MORREU V√âI<br>
            <span style="font-size: 24px">Pressione R para reiniciar</span>
        </div>
        <div id="instructions">
            WASD: MOVER | MOUSE: MIRAR | CLIQUE: ATIRAR | ESPA√áO: DASH | E: INTERAGIR
        </div>
        <div id="audioControls">
            <button onclick="toggleMusic()">üéµ M√öSICA</button>
        </div>
        <div id="debugInfo">
            <div>Sprites carregados: <span id="debugSprites">0</span>/48</div>
            <div>N√≠vel: <span id="debugLevel">1</span></div>
            <div>Inimigos: <span id="debugEnemies">0</span></div>
        </div>
    </div>
    
    <audio id="gameMusic" loop>
        <source src="musica.ogg" type="audio/ogg">
        <source src="musica.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Sistema de √°udio
        const gameMusic = document.getElementById('gameMusic');
        gameMusic.volume = 0.5;
        let musicStarted = false;
        
        function toggleMusic() {
            if (gameMusic.paused) {
                gameMusic.play().catch(e => console.log('Erro ao tocar m√∫sica:', e));
            } else {
                gameMusic.pause();
            }
        }
        
        // Inicia m√∫sica automaticamente
        function startMusic() {
            if (!musicStarted) {
                musicStarted = true;
                gameMusic.play().catch(e => {
                    console.log('M√∫sica bloqueada pelo navegador. Clique para iniciar.');
                    // Tenta novamente no pr√≥ximo clique
                    window.addEventListener('click', () => {
                        gameMusic.play().catch(() => {});
                    }, { once: true });
                });
            }
        }
        
        // Tenta iniciar m√∫sica imediatamente
        window.addEventListener('DOMContentLoaded', startMusic);
        window.addEventListener('click', startMusic, { once: true });
        window.addEventListener('keydown', startMusic, { once: true });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas vis√≠vel (viewport)
        canvas.width = 960;
        canvas.height = 640;
        
        // Mundo do jogo (4x maior na largura)
        const WORLD_WIDTH = 3840;
        const WORLD_HEIGHT = 640;

        ctx.imageSmoothingEnabled = false;

        // Estado do jogo
        const game = {
            score: 0,
            combo: 1,
            comboTimer: 0,
            paused: false,
            over: false,
            screenShake: 0,
            time: 0,
            bloodParticles: [],
            deathRotation: 0,
            deathRotationSpeed: 0.05,
            cameraX: 0,
            cameraY: 0,
            currentLevel: 0,
            levelComplete: false,
            bombPlanted: false,
            bombTimer: 30,
            escapeMode: false,
            bombX: 0,
            bombY: 0
        };

        // Paleta de cores neon
        const colors = {
            player: '#00ff88',
            enemy: '#ff0066',
            bullet: '#ffff00',
            blood: ['#ff0066', '#cc0052', '#990039', '#660026'],
            wall: '#1a0033',
            floor: '#2a2a2a',
            neonBlue: '#00ffff',
            neonPink: '#ff00ff',
            neonPurple: '#9945ff',
            enemyGlow: '#ff00ff',
            bombGlow: '#ff0000',
            carColor: '#444',
            carAccent: '#666',
            visionCone: '#ffff0033' // Amarelo transparente para cone de vis√£o
        };

        // Sistema de Sprites
        const sprites = {
            loaded: false,
            loadedCount: 0,
            totalSprites: 48,
            player: {
                idle: [],
                ride: [],
                wheelie: [],
                death: []
            },
            enemies: {
                janis: {
                    idle: [],
                    ride: [],
                    wheelie: [],
                    death: []
                },
                janis2: {
                    idle: [],
                    ride: [],
                    wheelie: [],
                    death: []
                }
            },
            objects: {
                car: null,
                post: null,
                barrel: null,
                car_destroyed: null,
                explosion: []
            }
        };

        // Objetos de cen√°rio
        const sceneObjects = [];

        // Classe para objetos de cen√°rio
        class SceneObject {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                
                switch(type) {
                    case 'car':
                        this.width = 60;
                        this.height = 40;
                        this.destructible = true;
                        this.health = 3;
                        break;
                    case 'post':
                        this.width = 20;
                        this.height = 20;
                        this.destructible = false;
                        break;
                    case 'barrel':
                        this.width = 25;
                        this.height = 25;
                        this.destructible = true;
                        this.health = 1;
                        this.explosive = true;
                        break;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Tenta usar sprite real primeiro
                if (sprites.objects[this.type] && sprites.objects[this.type].complete) {
                    const sprite = sprites.objects[this.type];
                    ctx.drawImage(sprite, -sprite.width/2, -sprite.height/2);
                } else {
                    // Desenho procedural (fallback)
                    switch(this.type) {
                        case 'car':
                            ctx.fillStyle = colors.carColor;
                            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                            ctx.fillStyle = '#222';
                            ctx.fillRect(-this.width/3, -this.height/3, this.width/3, this.height/1.5);
                            ctx.fillRect(this.width/6, -this.height/3, this.width/3, this.height/1.5);
                            ctx.fillStyle = '#ffff00';
                            ctx.fillRect(this.width/2 - 5, -this.height/3, 5, 8);
                            ctx.fillRect(this.width/2 - 5, this.height/3 - 8, 5, 8);
                            break;
                            
                        case 'post':
                            ctx.fillStyle = '#333';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ffff00';
                            ctx.fillStyle = '#ffff00';
                            ctx.beginPath();
                            ctx.arc(0, -5, 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            break;
                            
                        case 'barrel':
                            ctx.fillStyle = '#ff4400';
                            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                            ctx.fillStyle = '#ffff00';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('‚ö†', 0, 0);
                            break;
                    }
                }
            }
        }
            
            takeDamage(damage) {
                if (!this.destructible) return false;
                
                this.health -= damage;
                if (this.health <= 0) {
                    if (this.explosive) {
                        createExplosion(this.x, this.y, 100);
                        game.screenShake = 20;
                    } else {
                        createParticles(this.x, this.y, colors.carColor, 15, 6);
                    }
                    return true;
                }
                return false;
            }
            
            checkCollision(x, y, size) {
                const dx = Math.abs(x - this.x);
                const dy = Math.abs(y - this.y);
                return dx < (this.width + size) / 2 && dy < (this.height + size) / 2;
            }
        }

        // Sistema de bomba
        const bomb = {
            planted: false,
            x: 0,
            y: 0,
            timer: 30,
            blinkSpeed: 1,
            size: 30
        };

        // Fun√ß√£o para criar explos√£o
        function createExplosion(x, y, radius) {
            enemies.forEach((enemy, index) => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < radius) {
                    enemy.health = 0;
                    corpses.push({
                        x: enemy.x,
                        y: enemy.y,
                        angle: enemy.angle,
                        size: enemy.size,
                        color: enemy.color
                    });
                    enemies.splice(index, 1);
                    createBloodSplatter(enemy.x, enemy.y, 20);
                }
            });
            
            const pdx = player.x - x;
            const pdy = player.y - y;
            const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
            if (pdist < radius && player.invulnerable <= 0) {
                player.health--;
                player.invulnerable = 60;
                game.screenShake = 15;
            }
            
            createParticles(x, y, '#ff8800', 30, 15);
            createParticles(x, y, '#ffff00', 20, 10);
            createParticles(x, y, '#ff0000', 25, 12);
        }

        // Carrega sprites
        function loadSprites() {
            console.log('üèçÔ∏è Preparando sprites...');
            
            // Sprites procedurais como fallback
            const actions = ['idle', 'ride', 'wheelie', 'death'];
            const characterColors = {
                bike: '#333',
                rider: '#ff0066',
                wheel: '#222',
                janisBody: '#ff00ff',
                janisHair: '#cc00cc'
            };
            
            // Sprites do player
            actions.forEach(action => {
                for (let dir = 0; dir < 4; dir++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.save();
                    ctx.translate(32, 32);
                    ctx.rotate(dir * Math.PI / 2);
                    
                    if (action === 'wheelie') {
                        ctx.rotate(-0.3);
                    }
                    
                    ctx.fillStyle = characterColors.bike;
                    ctx.fillRect(-20, -5, 40, 10);
                    
                    ctx.fillStyle = characterColors.wheel;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = characterColors.rider;
                    if (action === 'death') {
                        ctx.fillRect(-5, -15, 10, 20);
                    } else {
                        ctx.fillRect(-5, -10, 10, 15);
                        ctx.beginPath();
                        ctx.arc(0, -10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    sprites.player[action][dir] = canvas;
                }
            });
            
            // Sprites procedurais da Janis (personagem feminina cyberpunk)
            ['janis', 'janis2'].forEach(enemyType => {
                actions.forEach(action => {
                    for (let dir = 0; dir < 4; dir++) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.save();
                        ctx.translate(32, 32);
                        ctx.rotate(dir * Math.PI / 2);
                        
                        // Corpo da Janis
                        ctx.fillStyle = characterColors.janisBody;
                        
                        if (action === 'death') {
                            // Ca√≠da
                            ctx.fillRect(-8, -15, 16, 25);
                        } else {
                            // Corpo
                            ctx.fillRect(-6, -10, 12, 18);
                            
                            // Cabe√ßa
                            ctx.beginPath();
                            ctx.arc(0, -12, 7, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Cabelo
                            ctx.fillStyle = characterColors.janisHair;
                            ctx.fillRect(-8, -18, 16, 8);
                            ctx.fillRect(-10, -16, 3, 12);
                            ctx.fillRect(7, -16, 3, 12);
                            
                            // Bra√ßos
                            ctx.fillStyle = characterColors.janisBody;
                            ctx.fillRect(-10, -8, 4, 10);
                            ctx.fillRect(6, -8, 4, 10);
                            
                            // Arma quando armada
                            if (action === 'wheelie') {
                                ctx.fillStyle = '#ffff00';
                                ctx.fillRect(8, -6, 12, 3);
                            }
                            
                            // Pernas
                            ctx.fillStyle = characterColors.janisBody;
                            ctx.fillRect(-4, 8, 3, 8);
                            ctx.fillRect(1, 8, 3, 8);
                        }
                        
                        ctx.restore();
                        
                        sprites.enemies[enemyType][action][dir] = canvas;
                    }
                });
            });
            
            sprites.loaded = true;
            console.log('‚úÖ Sprites procedurais criados!');
            
            // Tenta carregar sprites de objetos
            function loadObjectSprite(filename, objName) {
                const img = new Image();
                img.src = './' + filename;
                img.onload = () => {
                    sprites.objects[objName] = img;
                    console.log(`‚úÖ Sprite ${filename} carregado!`);
                };
                img.onerror = () => {
                    console.log(`‚ö†Ô∏è Sprite ${filename} n√£o encontrado, usando procedural`);
                };
            }
            
            // Carrega sprites de objetos (se existirem)
            loadObjectSprite('car.png', 'car');
            loadObjectSprite('post.png', 'post');
            loadObjectSprite('barrel.png', 'barrel');
            loadObjectSprite('car_destroyed.png', 'car_destroyed');
            
            // Tenta carregar anima√ß√£o de explos√£o
            for (let i = 1; i <= 8; i++) {
                const num = i.toString().padStart(3, '0');
                loadObjectSprite(`explosion_${num}.png`, `explosion_${i-1}`);
            }
            
            // Tenta carregar imagens reais
            function loadImage(src, category, index) {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    sprites.player[category][index] = img;
                    sprites.loadedCount++;
                    document.getElementById('debugSprites').textContent = sprites.loadedCount;
                };
                img.onerror = () => {
                    sprites.loadedCount++;
                    document.getElementById('debugSprites').textContent = sprites.loadedCount;
                };
            }
            
            const spritePath = './';
            
            // Carrega sprites do Mad Max
            for (let i = 0; i < 4; i++) {
                loadImage(spritePath + `madmax00${i}.png`, 'idle', i);
                loadImage(spritePath + `madmax00${i + 8}.png`, 'wheelie', i);
                loadImage(spritePath + `madmax0${i + 12}.png`, 'death', i);
            }
            
            for (let i = 0; i < 4; i++) {
                loadImage(spritePath + `madmax00${i}.png`, 'ride', i * 2);
                loadImage(spritePath + `madmax00${i + 4}.png`, 'ride', i * 2 + 1);
            }
        }

        loadSprites();

        // Jogador
        const player = {
            x: 200,
            y: 320,
            size: 24,
            speed: 5,
            dashSpeed: 15,
            health: 3,
            maxHealth: 3,
            color: colors.player,
            attacking: false,
            attackCooldown: 0,
            invulnerable: 0,
            angle: 0,
            dashCooldown: 0,
            trail: [],
            sprite: null,
            frameTime: 0,
            currentAction: 'idle',
            direction: 0,
            isMoving: false,
            onBike: true,
            animFrame: 0,
            animTimer: 0,
            hasBomb: false
        };

        // Controles
        const keys = {};
        const mouse = { x: 0, y: 0, worldX: 0, worldY: 0, pressed: false };

        // Arrays do jogo
        const enemies = [];
        const projectiles = [];
        const particles = [];
        const corpses = [];

        // Sistema de n√≠veis aprimorado
        const levels = [
            {
                name: "Tutorial - Aprenda os Controles",
                playerStart: { x: 200, y: 320 },
                exit: { x: 3700, y: 320, width: 60, height: 100 },
                enemies: [],
                sceneObjects: [
                    { x: 600, y: 200, type: 'barrel' },
                    { x: 600, y: 400, type: 'barrel' },
                    { x: 1200, y: 320, type: 'car' },
                    { x: 1800, y: 200, type: 'post' },
                    { x: 1800, y: 400, type: 'post' },
                    { x: 2400, y: 320, type: 'car' },
                    { x: 3000, y: 200, type: 'barrel' },
                    { x: 3000, y: 400, type: 'barrel' }
                ],
                message: "Atire nos barris! Use ESPA√áO para dash!"
            },
            {
                name: "Entrada do Territ√≥rio",
                playerStart: { x: 200, y: 320 },
                exit: { x: 3700, y: 320, width: 60, height: 100 },
                enemies: [
                    { x: 1200, y: 320, type: 'janis', patrol: 'circle' },
                    { x: 2000, y: 200, type: 'janis', patrol: 'lookAround' },
                    { x: 2800, y: 400, type: 'janis', patrol: 'circle' }
                ],
                sceneObjects: [
                    { x: 400, y: 200, type: 'post' },
                    { x: 400, y: 400, type: 'post' },
                    { x: 800, y: 320, type: 'car' },
                    { x: 1600, y: 150, type: 'car' },
                    { x: 1600, y: 450, type: 'car' },
                    { x: 2400, y: 320, type: 'barrel' },
                    { x: 3200, y: 200, type: 'post' },
                    { x: 3200, y: 400, type: 'post' }
                ],
                message: "Evite ser visto pelos guardas!"
            },
            {
                name: "Zona de Patrulha",
                playerStart: { x: 200, y: 320 },
                exit: { x: 3700, y: 100, width: 60, height: 100 },
                bombLocation: { x: 1920, y: 320 },
                enemies: [
                    { x: 800, y: 200, type: 'janis', patrol: 'circle' },
                    { x: 1200, y: 400, type: 'janis2', patrol: 'lookAround' },
                    { x: 1600, y: 320, type: 'janis', patrol: 'horizontal' },
                    { x: 2400, y: 200, type: 'janis', patrol: 'circle' },
                    { x: 2800, y: 400, type: 'janis2', patrol: 'vertical' },
                    { x: 3200, y: 320, type: 'janis', patrol: 'lookAround' }
                ],
                sceneObjects: [
                    { x: 500, y: 150, type: 'car' },
                    { x: 500, y: 450, type: 'car' },
                    { x: 1000, y: 320, type: 'barrel' },
                    { x: 1400, y: 100, type: 'post' },
                    { x: 1400, y: 500, type: 'post' },
                    { x: 2000, y: 150, type: 'car' },
                    { x: 2000, y: 450, type: 'car' },
                    { x: 2600, y: 320, type: 'barrel' },
                    { x: 3400, y: 200, type: 'post' },
                    { x: 3400, y: 400, type: 'post' }
                ],
                message: "Elimine os guardas e plante a bomba!"
            },
            {
                name: "Base Inimiga",
                playerStart: { x: 200, y: 100 },
                exit: { x: 200, y: 540, width: 100, height: 60 },
                bombLocation: { x: 3200, y: 500 },
                enemies: [
                    { x: 600, y: 320, type: 'janis2', patrol: 'circle' },
                    { x: 1000, y: 200, type: 'janis', patrol: 'lookAround' },
                    { x: 1000, y: 400, type: 'janis', patrol: 'lookAround' },
                    { x: 1600, y: 320, type: 'janis2', patrol: 'horizontal' },
                    { x: 2000, y: 100, type: 'janis', patrol: 'vertical' },
                    { x: 2000, y: 500, type: 'janis', patrol: 'vertical' },
                    { x: 2600, y: 300, type: 'janis2', patrol: 'circle' },
                    { x: 3000, y: 200, type: 'janis', patrol: 'lookAround' },
                    { x: 3400, y: 400, type: 'janis', patrol: 'horizontal' }
                ],
                sceneObjects: [
                    { x: 400, y: 320, type: 'car' },
                    { x: 800, y: 150, type: 'car' },
                    { x: 800, y: 450, type: 'car' },
                    { x: 1200, y: 250, type: 'barrel' },
                    { x: 1200, y: 350, type: 'barrel' },
                    { x: 1800, y: 150, type: 'post' },
                    { x: 1800, y: 450, type: 'post' },
                    { x: 2200, y: 320, type: 'car' },
                    { x: 2400, y: 200, type: 'barrel' },
                    { x: 2400, y: 400, type: 'barrel' },
                    { x: 2800, y: 150, type: 'post' },
                    { x: 2800, y: 450, type: 'post' },
                    { x: 3600, y: 320, type: 'car' }
                ],
                message: "A base principal! Plante a bomba no dep√≥sito!"
            }
        ];

        // Mapa melhorado
        const tileSize = 32;
        const mapWidth = Math.floor(WORLD_WIDTH / tileSize);
        const mapHeight = Math.floor(WORLD_HEIGHT / tileSize);
        let map = [];

        // Fun√ß√£o para gerar mapa do n√≠vel
        function generateLevelMap(levelIndex) {
            map = [];
            
            // Cria mapa vazio
            for (let y = 0; y < mapHeight; y++) {
                map[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    // Apenas bordas como paredes
                    if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1) {
                        map[y][x] = 1;
                    } else {
                        map[y][x] = 0;
                    }
                }
            }
            
            // Obt√©m n√≠vel atual
            const level = levels[levelIndex];
            if (!level) return;
            
            // Cria lista de todas as posi√ß√µes ocupadas (com margem de seguran√ßa)
            const occupiedTiles = new Set();
            
            // Fun√ß√£o auxiliar para marcar √°rea como ocupada
            function markOccupiedArea(worldX, worldY, radiusTiles) {
                const centerX = Math.floor(worldX / tileSize);
                const centerY = Math.floor(worldY / tileSize);
                
                for (let dy = -radiusTiles; dy <= radiusTiles; dy++) {
                    for (let dx = -radiusTiles; dx <= radiusTiles; dx++) {
                        const tileX = centerX + dx;
                        const tileY = centerY + dy;
                        if (tileX >= 0 && tileX < mapWidth && tileY >= 0 && tileY < mapHeight) {
                            occupiedTiles.add(`${tileX},${tileY}`);
                        }
                    }
                }
            }
            
            // Marca √°rea do jogador
            markOccupiedArea(level.playerStart.x, level.playerStart.y, 4);
            
            // Marca √°reas dos inimigos
            if (level.enemies) {
                level.enemies.forEach(enemy => {
                    markOccupiedArea(enemy.x, enemy.y, 3);
                });
            }
            
            // Marca √°reas dos objetos
            if (level.sceneObjects) {
                level.sceneObjects.forEach(obj => {
                    markOccupiedArea(obj.x, obj.y, 3);
                });
            }
            
            // Marca √°rea da sa√≠da
            if (level.exit) {
                markOccupiedArea(level.exit.x, level.exit.y, 4);
            }
            
            // Marca √°rea da bomba
            if (level.bombLocation) {
                markOccupiedArea(level.bombLocation.x, level.bombLocation.y, 4);
            }
            
            // Agora adiciona paredes apenas em √°reas seguras
            if (levelIndex === 0) {
                // Tutorial: corredores verticais simples
                for (let i = 1; i < 7; i++) {
                    const x = 15 + i * 18;
                    if (x < mapWidth - 1) {
                        for (let y = 2; y < mapHeight - 2; y++) {
                            // Cria abertura no meio
                            if ((y < 7 || y > 12) && !occupiedTiles.has(`${x},${y}`)) {
                                map[y][x] = 1;
                            }
                        }
                    }
                }
            } else if (levelIndex === 1) {
                // N√≠vel 1: algumas paredes estrat√©gicas
                // Parede horizontal superior
                for (let x = 15; x < 35; x++) {
                    if (!occupiedTiles.has(`${x},6`)) {
                        map[6][x] = 1;
                    }
                }
                
                // Parede horizontal inferior
                for (let x = 50; x < 70; x++) {
                    if (!occupiedTiles.has(`${x},13`)) {
                        map[13][x] = 1;
                    }
                }
                
                // Algumas paredes verticais
                for (let y = 4; y < 10; y++) {
                    if (!occupiedTiles.has(`45,${y}`)) {
                        map[y][45] = 1;
                    }
                }
                
                for (let y = 10; y < 16; y++) {
                    if (!occupiedTiles.has(`75,${y}`)) {
                        map[y][75] = 1;
                    }
                }
            } else if (levelIndex === 2) {
                // N√≠vel 2: labirinto mais complexo
                // Cria algumas salas
                
                // Sala 1 (esquerda)
                for (let x = 25; x < 45; x++) {
                    if (!occupiedTiles.has(`${x},5`)) map[5][x] = 1;
                    if (!occupiedTiles.has(`${x},15`)) map[15][x] = 1;
                }
                for (let y = 5; y < 16; y++) {
                    if (!occupiedTiles.has(`25,${y}`)) map[y][25] = 1;
                    if (!occupiedTiles.has(`45,${y}`)) map[y][45] = 1;
                }
                // Portas
                map[10][25] = 0;
                map[10][45] = 0;
                
                // Sala 2 (centro)
                for (let x = 55; x < 75; x++) {
                    if (!occupiedTiles.has(`${x},7`)) map[7][x] = 1;
                    if (!occupiedTiles.has(`${x},13`)) map[13][x] = 1;
                }
                for (let y = 7; y < 14; y++) {
                    if (!occupiedTiles.has(`55,${y}`)) map[y][55] = 1;
                    if (!occupiedTiles.has(`75,${y}`)) map[y][75] = 1;
                }
                // Portas
                map[10][55] = 0;
                map[10][75] = 0;
                
                // Corredores conectando
                for (let x = 45; x < 55; x++) {
                    if (!occupiedTiles.has(`${x},8`)) map[8][x] = 1;
                    if (!occupiedTiles.has(`${x},12`)) map[12][x] = 1;
                }
            } else if (levelIndex === 3) {
                // N√≠vel 3: base com m√∫ltiplas rotas
                
                // Paredes principais horizontais
                for (let i = 0; i < 5; i++) {
                    const y = 4 + i * 3;
                    for (let x = 10 + i * 5; x < mapWidth - 10 - i * 5; x++) {
                        if (!occupiedTiles.has(`${x},${y}`) && Math.random() > 0.3) {
                            map[y][x] = 1;
                        }
                    }
                }
                
                // Cria aberturas estrat√©gicas
                for (let i = 0; i < 10; i++) {
                    const x = 20 + i * 10;
                    const y = 4 + (i % 5) * 3;
                    if (x < mapWidth && y < mapHeight) {
                        // Cria abertura de 3 tiles
                        for (let dx = -1; dx <= 1; dx++) {
                            if (x + dx > 0 && x + dx < mapWidth - 1) {
                                map[y][x + dx] = 0;
                            }
                        }
                    }
                }
            }
        }

        generateLevelMap(0);

        // Classe de inimigo melhorada com patrulha
        class Enemy {
            constructor(x, y, type = 'janis', patrol = 'circle') {
                this.x = x;
                this.y = y;
                this.startX = x;
                this.startY = y;
                this.size = 20;
                this.speed = 2 + Math.random();
                this.health = 2;
                this.maxHealth = 2;
                this.color = '#ff00ff';
                this.angle = 0;
                this.type = type;
                this.behavior = Math.random() > 0.7 ? 'rusher' : 'normal';
                this.glowIntensity = 0;
                this.hitFlash = 0;
                this.active = false;
                this.detectionRange = 200;
                this.visionAngle = Math.PI / 3; // 60 graus de cone de vis√£o
                this.currentAction = 'idle';
                this.direction = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.shootCooldown = 0;
                this.patrol = patrol;
                this.patrolTimer = 0;
                this.patrolDirection = 1;
                this.lookDirection = 0;
                
                if (type === 'janis2') {
                    this.speed *= 1.2;
                    this.detectionRange = 250;
                    this.health = 3;
                    this.maxHealth = 3;
                    this.visionAngle = Math.PI / 2.5; // Vis√£o mais ampla
                }
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Patrulha quando n√£o ativo
                if (!this.active && !game.escapeMode) {
                    this.doPatrol();
                }
                
                const hasLineOfSight = this.checkLineOfSight(player.x, player.y);
                const inVisionCone = this.isInVisionCone(player.x, player.y);
                
                if (!this.active && distance < this.detectionRange && hasLineOfSight && inVisionCone) {
                    this.active = true;
                    this.currentAction = 'wheelie';
                    createParticles(this.x, this.y, colors.neonPink, 10, 5);
                }
                
                if (game.escapeMode) {
                    this.speed = 4;
                    this.detectionRange = 300;
                    this.active = true;
                }
                
                if (this.active && distance > 0) {
                    const moveSpeed = this.behavior === 'rusher' ? this.speed * 1.5 : this.speed;
                    
                    const nextX = this.x + (dx / distance) * moveSpeed;
                    const nextY = this.y + (dy / distance) * moveSpeed;
                    
                    let canMoveX = !checkWallCollision(nextX, this.y, this.size);
                    let canMoveY = !checkWallCollision(this.x, nextY, this.size);
                    
                    sceneObjects.forEach(obj => {
                        if (obj.checkCollision(nextX, this.y, this.size)) canMoveX = false;
                        if (obj.checkCollision(this.x, nextY, this.size)) canMoveY = false;
                    });
                    
                    if (canMoveX) this.x = nextX;
                    if (canMoveY) this.y = nextY;
                    
                    if (canMoveX || canMoveY) {
                        this.currentAction = 'ride';
                        this.animTimer++;
                        if (this.animTimer > 6) {
                            this.animTimer = 0;
                            this.animFrame = (this.animFrame + 1) % 2;
                        }
                    } else if (this.active) {
                        this.currentAction = 'wheelie';
                    }
                    
                    this.angle = Math.atan2(dy, dx);
                    this.updateDirection();
                    
                    if (this.currentAction === 'wheelie' && distance < 200 && this.shootCooldown <= 0) {
                        this.shoot();
                        this.shootCooldown = 60;
                    }
                } else if (!this.active) {
                    // Atualiza dire√ß√£o baseada no √¢ngulo de patrulha
                    this.updateDirection();
                }
                
                if (this.shootCooldown > 0) this.shootCooldown--;

                // Colis√£o com o jogador
                if (distance < this.size + player.size && player.invulnerable <= 0) {
                    player.health -= 1;
                    player.invulnerable = 60;
                    game.screenShake = 10;
                    createBloodSplatter(player.x, player.y, 20);
                    
                    const knockbackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.x += Math.cos(knockbackAngle) * 20;
                    player.y += Math.sin(knockbackAngle) * 20;
                }

                this.glowIntensity = Math.sin(game.time * 0.1) * 0.5 + 0.5;
                if (this.hitFlash > 0) this.hitFlash--;
            }
            
            doPatrol() {
                this.patrolTimer++;
                
                switch(this.patrol) {
                    case 'circle':
                        // Anda em c√≠rculo
                        const radius = 50;
                        const speed = 0.02;
                        this.x = this.startX + Math.cos(this.patrolTimer * speed) * radius;
                        this.y = this.startY + Math.sin(this.patrolTimer * speed) * radius;
                        this.angle = Math.atan2(
                            Math.sin(this.patrolTimer * speed + 0.1) * radius - Math.sin(this.patrolTimer * speed) * radius,
                            Math.cos(this.patrolTimer * speed + 0.1) * radius - Math.cos(this.patrolTimer * speed) * radius
                        );
                        this.currentAction = 'ride';
                        break;
                        
                    case 'lookAround':
                        // Fica parado olhando para os lados
                        this.currentAction = 'idle';
                        if (this.patrolTimer % 120 === 0) {
                            this.lookDirection = (this.lookDirection + 1) % 4;
                            this.angle = this.lookDirection * Math.PI / 2;
                        }
                        break;
                        
                    case 'horizontal':
                        // Anda horizontalmente
                        this.currentAction = 'ride';
                        this.x += this.patrolDirection * 2;
                        if (Math.abs(this.x - this.startX) > 100) {
                            this.patrolDirection *= -1;
                        }
                        this.angle = this.patrolDirection > 0 ? 0 : Math.PI;
                        break;
                        
                    case 'vertical':
                        // Anda verticalmente
                        this.currentAction = 'ride';
                        this.y += this.patrolDirection * 2;
                        if (Math.abs(this.y - this.startY) > 100) {
                            this.patrolDirection *= -1;
                        }
                        this.angle = this.patrolDirection > 0 ? Math.PI/2 : -Math.PI/2;
                        break;
                }
                
                // Anima√ß√£o de andar durante patrulha
                if (this.currentAction === 'ride') {
                    this.animTimer++;
                    if (this.animTimer > 8) {
                        this.animTimer = 0;
                        this.animFrame = (this.animFrame + 1) % 2;
                    }
                }
            }
            
            updateDirection() {
                const angle = this.angle;
                if (angle > -Math.PI/4 && angle <= Math.PI/4) this.direction = 0; // Direita
                else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) this.direction = 1; // Baixo
                else if (angle > 3*Math.PI/4 || angle <= -3*Math.PI/4) this.direction = 2; // Esquerda
                else this.direction = 3; // Cima
            }
            
            isInVisionCone(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const angleToTarget = Math.atan2(dy, dx);
                
                let angleDiff = angleToTarget - this.angle;
                // Normaliza o √¢ngulo para [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                return Math.abs(angleDiff) < this.visionAngle / 2;
            }
            
            shoot() {
                const bulletAngle = Math.atan2(player.y - this.y, player.x - this.x);
                projectiles.push(new EnemyProjectile(this.x, this.y, bulletAngle));
                createParticles(this.x, this.y, '#ff00ff', 5, 3);
            }
            
            checkLineOfSight(targetX, targetY) {
                const steps = 20;
                const stepX = (targetX - this.x) / steps;
                const stepY = (targetY - this.y) / steps;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + stepX * i;
                    const checkY = this.y + stepY * i;
                    
                    const tileX = Math.floor(checkX / tileSize);
                    const tileY = Math.floor(checkY / tileSize);
                    
                    if (map[tileY] && map[tileY][tileX] === 1) {
                        return false;
                    }
                    
                    for (let obj of sceneObjects) {
                        if (obj.checkCollision(checkX, checkY, 5)) {
                            return false;
                        }
                    }
                }
                
                return true;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Desenha cone de vis√£o ANTES do personagem
                if (!this.active) {
                    ctx.save();
                    ctx.rotate(this.angle);
                    ctx.fillStyle = colors.visionCone;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, this.detectionRange, -this.visionAngle/2, this.visionAngle/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                
                // Desenha o personagem
                ctx.rotate(this.angle);
                
                // Tenta usar sprites da Janis
                if (sprites.loaded && sprites.enemies[this.type] && sprites.enemies[this.type][this.currentAction]) {
                    const spriteArray = sprites.enemies[this.type][this.currentAction];
                    let sprite;
                    
                    if (this.currentAction === 'ride') {
                        const frameIndex = this.animFrame; // Usa s√≥ o frame de anima√ß√£o
                        sprite = spriteArray[frameIndex] || spriteArray[0];
                    } else {
                        sprite = spriteArray[this.direction] || spriteArray[0];
                    }
                    
                    if (sprite && sprite.complete) {
                        if (this.hitFlash > 0) {
                            ctx.filter = 'brightness(2)';
                        }
                        
                        ctx.drawImage(sprite, -32, -32, 64, 64);
                        ctx.filter = 'none';
                    } else {
                        // Fallback para desenho procedural
                        this.drawProcedural();
                    }
                } else {
                    // Desenho procedural da Janis
                    this.drawProcedural();

            
            drawProcedural() {
                // Desenho procedural da Janis como fallback
                ctx.shadowBlur = 30;
                ctx.shadowColor = colors.enemyGlow;
                
                if (this.hitFlash > 0) {
                    ctx.fillStyle = '#ffffff';
                } else {
                    ctx.fillStyle = colors.enemyGlow;
                }
                
                // Corpo feminino estilizado
                ctx.fillRect(-6, -10, 12, 18);
                
                // Cabe√ßa
                ctx.beginPath();
                ctx.arc(0, -12, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Cabelo
                ctx.fillStyle = '#cc00cc';
                ctx.fillRect(-8, -18, 16, 8);
                ctx.fillRect(-10, -16, 3, 12);
                ctx.fillRect(7, -16, 3, 12);
                
                // Bra√ßos
                ctx.fillStyle = colors.enemyGlow;
                ctx.fillRect(-10, -8, 4, 10);
                ctx.fillRect(6, -8, 4, 10);
                
                // Arma quando armada
                if (this.currentAction === 'wheelie') {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(8, -6, 12, 3);
                }
                
                // Pernas
                ctx.fillRect(-4, 8, 3, 8);
                ctx.fillRect(1, 8, 3, 8);
                
                // Olhos
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-3, -14, 2, 3);
                ctx.fillRect(1, -14, 2, 3);
                
                // Indicador de tipo
                if (this.type === 'janis2') {
                    ctx.fillStyle = '#ff0000';
                }
                
                ctx.restore();
            }
                    
                    if (this.hitFlash > 0) {
                        ctx.fillStyle = '#ffffff';
                    } else {
                        ctx.fillStyle = colors.enemyGlow;
                    }
                    
                    // Corpo feminino estilizado
                    ctx.fillRect(-6, -10, 12, 18);
                    
                    // Cabe√ßa
                    ctx.beginPath();
                    ctx.arc(0, -12, 7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Cabelo
                    ctx.fillStyle = '#cc00cc';
                    ctx.fillRect(-8, -18, 16, 8);
                    ctx.fillRect(-10, -16, 3, 12);
                    ctx.fillRect(7, -16, 3, 12);
                    
                    // Bra√ßos
                    ctx.fillStyle = colors.enemyGlow;
                    ctx.fillRect(-10, -8, 4, 10);
                    ctx.fillRect(6, -8, 4, 10);
                    
                    // Arma quando armada
                    if (this.currentAction === 'wheelie') {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(8, -6, 12, 3);
                    }
                    
                    // Pernas
                    ctx.fillRect(-4, 8, 3, 8);
                    ctx.fillRect(1, 8, 3, 8);
                    
                    // Olhos
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-3, -14, 2, 3);
                    ctx.fillRect(1, -14, 2, 3);
                    
                    // Indicador de tipo
                    if (this.type === 'janis2') {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-3, -20, 6, 3);
                    }
                }
                
                ctx.restore();
            }
        }

        // Proj√©til inimigo
        class EnemyProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.speed = 8;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 4;
                this.damage = 1;
                this.color = '#ff00ff';
                this.life = 60;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                
                const tileX = Math.floor(this.x / tileSize);
                const tileY = Math.floor(this.y / tileSize);
                if (map[tileY] && map[tileY][tileX] === 1) {
                    return true;
                }
                
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.size + this.size && player.invulnerable <= 0) {
                    player.health -= this.damage;
                    player.invulnerable = 60;
                    game.screenShake = 8;
                    createBloodSplatter(player.x, player.y, 10);
                    return true;
                }
                
                return this.life <= 0;
            }
            
            draw() {
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.shadowBlur = 0;
            }
        }

        // Fun√ß√£o para verificar colis√£o com paredes
        function checkWallCollision(x, y, size) {
            const corners = [
                { x: x - size/2, y: y - size/2 },
                { x: x + size/2, y: y - size/2 },
                { x: x - size/2, y: y + size/2 },
                { x: x + size/2, y: y + size/2 }
            ];
            
            for (let corner of corners) {
                const tileX = Math.floor(corner.x / tileSize);
                const tileY = Math.floor(corner.y / tileSize);
                
                if (map[tileY] && map[tileY][tileX] === 1) {
                    return true;
                }
            }
            
            return false;
        }

        // Sistema de part√≠culas
        function createParticles(x, y, color, count, speed = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed * (0.5 + Math.random()),
                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Sistema de sangue
        function createBloodSplatter(x, y, count) {
            for (let i = 0; i < count; i++) {
                game.bloodParticles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    size: Math.random() * 8 + 4,
                    color: colors.blood[Math.floor(Math.random() * colors.blood.length)]
                });
            }
        }

        // Proj√©til do jogador
        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.speed = 15;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 6;
                this.damage = 1;
                this.trail = [];
                this.life = 60;
                this.piercing = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) {
                    this.trail.shift();
                }

                const tileX = Math.floor(this.x / tileSize);
                const tileY = Math.floor(this.y / tileSize);
                if (map[tileY] && map[tileY][tileX] === 1) {
                    createParticles(this.x, this.y, colors.bullet, 5, 4);
                    return true;
                }
                
                let hitObject = false;
                sceneObjects.forEach((obj, index) => {
                    if (obj.checkCollision(this.x, this.y, this.size)) {
                        if (obj.takeDamage(this.damage)) {
                            sceneObjects.splice(index, 1);
                        }
                        createParticles(this.x, this.y, colors.bullet, 3, 3);
                        hitObject = true;
                    }
                });
                
                if (hitObject && !this.piercing) return true;

                let hit = false;
                enemies.forEach((enemy, index) => {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + this.size) {
                        enemy.health -= this.damage;
                        enemy.hitFlash = 5;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        
                        if (enemy.health <= 0) {
                            corpses.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: enemy.angle,
                                size: enemy.size,
                                color: enemy.color
                            });
                            
                            enemies.splice(index, 1);
                            game.score += 100 * game.combo;
                            game.combo = Math.min(game.combo + 1, 10);
                            game.comboTimer = 120;
                            createParticles(enemy.x, enemy.y, colors.neonPink, 20, 10);
                            game.screenShake = 8;
                        }
                        
                        if (!this.piercing) hit = true;
                    }
                });
                
                return hit || this.life <= 0;
            }

            draw() {
                this.trail.forEach((point, index) => {
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = colors.bullet;
                    ctx.fillStyle = colors.bullet;
                    ctx.fillRect(point.x - 3, point.y - 3, 6, 6);
                });
                ctx.globalAlpha = 1;

                ctx.shadowBlur = 20;
                ctx.shadowColor = colors.bullet;
                ctx.fillStyle = colors.bullet;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.shadowBlur = 0;
            }
        }

        // Carrega n√≠vel
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            sceneObjects.length = 0;
            game.bloodParticles.length = 0;
            game.levelComplete = false;
            game.bombPlanted = false;
            game.escapeMode = false;
            player.hasBomb = false;
            
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.health = player.maxHealth;
            
            generateLevelMap(levelIndex);
            
            if (level.sceneObjects) {
                level.sceneObjects.forEach(objData => {
                    sceneObjects.push(new SceneObject(objData.x, objData.y, objData.type));
                });
            }
            
            level.enemies.forEach(enemyData => {
                const enemy = new Enemy(enemyData.x, enemyData.y, enemyData.type || 'janis', enemyData.patrol || 'circle');
                enemies.push(enemy);
            });
            
            if (level.bombLocation) {
                bomb.x = level.bombLocation.x;
                bomb.y = level.bombLocation.y;
                bomb.planted = false;
                player.hasBomb = true;
            }
            
            updateObjective(level);
            
            console.log(`üéÆ ${level.message}`);
        }

        // Atualiza texto do objetivo
        function updateObjective(level) {
            const objDiv = document.getElementById('objective');
            if (level.bombLocation && !game.bombPlanted) {
                objDiv.textContent = "OBJETIVO: PLANTE A BOMBA (PRESSIONE E)";
            } else if (game.escapeMode) {
                objDiv.textContent = "FUJA! CHEGUE NA SA√çDA!";
                objDiv.style.color = '#ff0066';
                objDiv.style.animation = 'blink 0.5s infinite';
            } else {
                objDiv.textContent = "OBJETIVO: ELIMINE OS INIMIGOS E SAIA";
            }
        }

        // Controles
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'r' && game.over) {
                resetGame();
            }
            
            if (e.key.toLowerCase() === 'e') {
                const level = levels[game.currentLevel];
                if (level && level.bombLocation && player.hasBomb && !game.bombPlanted) {
                    const dx = player.x - bomb.x;
                    const dy = player.y - bomb.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 50) {
                        game.bombPlanted = true;
                        game.escapeMode = true;
                        game.bombTimer = 30;
                        player.hasBomb = false;
                        
                        createParticles(bomb.x, bomb.y, colors.bombGlow, 20, 5);
                        game.screenShake = 10;
                        
                        document.getElementById('bombTimer').style.display = 'block';
                        updateObjective(level);
                        
                        for (let i = 0; i < 3; i++) {
                            spawnEnemy();
                        }
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            // Converte para coordenadas do mundo
            mouse.worldX = mouse.x + game.cameraX - canvas.width / 2;
            mouse.worldY = mouse.y + game.cameraY - canvas.height / 2;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.pressed = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.pressed = false;
        });

        // Reset do jogo
        function resetGame() {
            player.health = player.maxHealth;
            player.x = 200;
            player.y = 320;
            player.trail = [];
            player.currentAction = 'idle';
            player.hasBomb = false;
            game.score = 0;
            game.combo = 1;
            game.over = false;
            game.screenShake = 0;
            game.deathRotation = 0;
            game.deathRotationSpeed = 0.05;
            game.bombPlanted = false;
            game.escapeMode = false;
            game.bombTimer = 30;
            game.currentLevel = 0;
            game.cameraX = player.x;
            game.cameraY = player.y;
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            sceneObjects.length = 0;
            game.bloodParticles.length = 0;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('bombTimer').style.display = 'none';
            loadLevel(0);
        }

        // Spawn de inimigos
        function spawnEnemy() {
            const spawnPoints = [];
            
            for (let i = 0; i < 4; i++) {
                let x, y;
                const side = i;
                
                switch(side) {
                    case 0: x = Math.random() * WORLD_WIDTH; y = 40; break;
                    case 1: x = WORLD_WIDTH - 40; y = Math.random() * WORLD_HEIGHT; break;
                    case 2: x = Math.random() * WORLD_WIDTH; y = WORLD_HEIGHT - 40; break;
                    case 3: x = 40; y = Math.random() * WORLD_HEIGHT; break;
                }
                
                spawnPoints.push({ x, y });
            }
            
            let bestPoint = spawnPoints[0];
            let maxDist = 0;
            
            spawnPoints.forEach(point => {
                const dist = Math.sqrt(Math.pow(point.x - player.x, 2) + Math.pow(point.y - player.y, 2));
                if (dist > maxDist) {
                    maxDist = dist;
                    bestPoint = point;
                }
            });
            
            enemies.push(new Enemy(bestPoint.x, bestPoint.y, Math.random() > 0.5 ? 'janis' : 'janis2'));
            createParticles(bestPoint.x, bestPoint.y, colors.neonPurple, 10, 5);
        }

        // Game loop
        function update() {
            if (game.over) return;
            
            game.time++;

            // Movimento do jogador
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -1;
            if (keys['s'] || keys['arrowdown']) dy = 1;
            if (keys['a'] || keys['arrowleft']) dx = -1;
            if (keys['d'] || keys['arrowright']) dx = 1;
            
            if (dx > 0) player.direction = 0;
            else if (dy > 0) player.direction = 1;
            else if (dx < 0) player.direction = 2;
            else if (dy < 0) player.direction = 3;
            
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            player.isMoving = (dx !== 0 || dy !== 0);
            
            if (player.health <= 0) {
                player.currentAction = 'death';
            } else if (player.isMoving) {
                player.currentAction = 'ride';
            } else {
                player.currentAction = 'idle';
            }
            
            // Dash
            let currentSpeed = player.speed;
            if (keys[' '] && player.dashCooldown <= 0 && player.onBike) {
                currentSpeed = player.dashSpeed;
                player.dashCooldown = 30;
                player.currentAction = 'wheelie';
                createParticles(player.x, player.y, colors.neonBlue, 10, 5);
                game.screenShake = 5;
                
                enemies.forEach((enemy, index) => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + player.size + 10) {
                        enemy.health = 0;
                        corpses.push({
                            x: enemy.x,
                            y: enemy.y,
                            angle: enemy.angle,
                            size: enemy.size,
                            color: enemy.color
                        });
                        enemies.splice(index, 1);
                        game.score += 200 * game.combo;
                        game.combo = Math.min(game.combo + 1, 10);
                        game.comboTimer = 120;
                        createBloodSplatter(enemy.x, enemy.y, 30);
                        createParticles(enemy.x, enemy.y, colors.neonPink, 30, 12);
                        game.screenShake = 15;
                    }
                });
            }
            
            // Movimento com colis√£o
            const nextX = player.x + dx * currentSpeed;
            const nextY = player.y + dy * currentSpeed;
            
            let canMoveX = !checkWallCollision(nextX, player.y, player.size);
            let canMoveY = !checkWallCollision(player.x, nextY, player.size);
            
            sceneObjects.forEach(obj => {
                if (obj.checkCollision(nextX, player.y, player.size)) canMoveX = false;
                if (obj.checkCollision(player.x, nextY, player.size)) canMoveY = false;
            });
            
            if (canMoveX) player.x = nextX;
            if (canMoveY) player.y = nextY;
            
            // Limita player aos limites do mundo
            player.x = Math.max(player.size, Math.min(WORLD_WIDTH - player.size, player.x));
            player.y = Math.max(player.size, Math.min(WORLD_HEIGHT - player.size, player.y));
            
            if (player.dashCooldown > 0) {
                player.dashCooldown--;
                if (player.dashCooldown > 20) {
                    player.currentAction = 'wheelie';
                }
            }

            // Trail
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                player.trail.push({ 
                    x: player.x, 
                    y: player.y,
                    angle: player.angle
                });
                if (player.trail.length > 10) {
                    player.trail.shift();
                }
            }

            // √Çngulo do jogador baseado no mouse do mundo
            player.angle = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);

            // Anima√ß√£o
            if (player.currentAction === 'ride' && player.isMoving) {
                player.animTimer++;
                if (player.animTimer > 6) {
                    player.animTimer = 0;
                    player.animFrame = (player.animFrame + 1) % 2;
                }
            } else {
                player.animFrame = 0;
                player.animTimer = 0;
            }
            
            // Ataque
            if (mouse.pressed && player.attackCooldown <= 0) {
                projectiles.push(new Projectile(player.x, player.y, player.angle));
                player.attackCooldown = 8;
                game.screenShake = 3;
                
                player.x -= Math.cos(player.angle) * 3;
                player.y -= Math.sin(player.angle) * 3;
            }
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            if (player.invulnerable > 0) player.invulnerable--;

            // Combo timer
            if (game.comboTimer > 0) {
                game.comboTimer--;
            } else {
                game.combo = 1;
            }

            // Screen shake
            if (game.screenShake > 0) game.screenShake *= 0.9;

            // Atualiza c√¢mera para seguir o jogador
            game.cameraX = player.x;
            game.cameraY = player.y;
            
            // Limita c√¢mera aos limites do mundo
            game.cameraX = Math.max(canvas.width / 2, Math.min(WORLD_WIDTH - canvas.width / 2, game.cameraX));
            game.cameraY = Math.max(canvas.height / 2, Math.min(WORLD_HEIGHT - canvas.height / 2, game.cameraY));

            // Timer da bomba
            if (game.escapeMode && game.bombPlanted) {
                game.bombTimer -= 1/60;
                document.getElementById('timerValue').textContent = Math.ceil(game.bombTimer);
                
                if (game.bombTimer <= 0) {
                    createExplosion(bomb.x, bomb.y, 300);
                    game.screenShake = 30;
                    
                    const dx = player.x - bomb.x;
                    const dy = player.y - bomb.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 300) {
                        player.health = 0;
                    }
                    
                    game.bombPlanted = false;
                    game.escapeMode = false;
                    document.getElementById('bombTimer').style.display = 'none';
                }
                
                if (Math.random() < 0.02) {
                    spawnEnemy();
                }
            }

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.update());

            // Atualiza proj√©teis
            projectiles.forEach((projectile, index) => {
                if (projectile.update()) {
                    projectiles.splice(index, 1);
                }
            });

            // Atualiza part√≠culas
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Verifica sa√≠da do n√≠vel
            const level = levels[game.currentLevel];
            if (level && level.exit) {
                const exitDx = player.x - level.exit.x;
                const exitDy = player.y - level.exit.y;
                
                const canExit = Math.abs(exitDx) < level.exit.width/2 && 
                               Math.abs(exitDy) < level.exit.height/2;
                
                if (canExit) {
                    let canProceed = false;
                    
                    if (level.bombLocation) {
                        canProceed = game.bombPlanted || (!player.hasBomb && enemies.length === 0);
                    } else {
                        canProceed = enemies.length === 0;
                    }
                    
                    if (canProceed) {
                        game.currentLevel++;
                        if (game.currentLevel < levels.length) {
                            loadLevel(game.currentLevel);
                            createParticles(player.x, player.y, colors.neonBlue, 30, 10);
                        } else {
                            game.currentLevel = 0;
                            loadLevel(0);
                        }
                    }
                }
            }

            // Game over
            if (player.health <= 0 && !game.over) {
                game.over = true;
                player.currentAction = 'death';
                createBloodSplatter(player.x, player.y, 50);
                createParticles(player.x, player.y, colors.enemy, 30, 15);
                game.screenShake = 20;
                game.deathRotation = 0;
                
                setTimeout(() => {
                    document.getElementById('gameOver').style.display = 'block';
                }, 2000);
            }
            
            if (game.over) {
                game.deathRotation += game.deathRotationSpeed;
                if (game.deathRotationSpeed > 0.001) {
                    game.deathRotationSpeed *= 0.98;
                }
            }

            // Atualiza UI
            const heartsDiv = document.querySelector('#ui > div:first-child');
            if (heartsDiv) {
                heartsDiv.textContent = '‚ù§Ô∏è'.repeat(Math.max(0, player.health));
            }
            document.getElementById('score').textContent = game.score;
            document.getElementById('combo').textContent = game.combo;
            document.getElementById('debugLevel').textContent = game.currentLevel + 1;
            document.getElementById('debugEnemies').textContent = enemies.length;
        }

        function draw() {
            ctx.save();
            
            // Transla√ß√£o da c√¢mera
            const offsetX = canvas.width / 2 - game.cameraX;
            const offsetY = canvas.height / 2 - game.cameraY;
            
            // Rota√ß√£o na morte
            if (game.over) {
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.rotate(game.deathRotation);
                ctx.translate(-canvas.width/2, -canvas.height/2);
                
                const zoom = 1 + (game.deathRotation / 10);
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(zoom, zoom);
                ctx.translate(-canvas.width/2, -canvas.height/2);
            }
            
            // Screen shake
            if (game.screenShake > 1) {
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }
            
            // Aplica offset da c√¢mera
            ctx.translate(offsetX, offsetY);

            // Fundo
            ctx.fillStyle = colors.floor;
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // Grid do asfalto
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            for (let x = 0; x < WORLD_WIDTH; x += tileSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y < WORLD_HEIGHT; y += tileSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WORLD_WIDTH, y);
                ctx.stroke();
            }
            
            // Faixas
            ctx.strokeStyle = '#444';
            ctx.setLineDash([20, 10]);
            ctx.lineWidth = 3;
            for (let x = 400; x < WORLD_WIDTH; x += 400) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Sangue
            ctx.globalAlpha = 0.7;
            game.bloodParticles.forEach(blood => {
                ctx.fillStyle = blood.color;
                ctx.beginPath();
                ctx.arc(blood.x, blood.y, blood.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Paredes
            ctx.shadowBlur = 10;
            ctx.shadowColor = colors.neonPurple;
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = colors.wall;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                        ctx.strokeStyle = colors.neonPurple;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            }
            ctx.shadowBlur = 0;

            // Objetos de cen√°rio
            sceneObjects.forEach(obj => obj.draw());

            // Local da bomba
            const level = levels[game.currentLevel];
            if (level && level.bombLocation && !game.bombPlanted && player.hasBomb) {
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                
                const pulse = Math.sin(game.time * 0.05) * 0.3 + 0.7;
                ctx.globalAlpha = pulse;
                ctx.strokeStyle = colors.bombGlow;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = colors.bombGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = colors.bombGlow;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('X', 0, 0);
                
                ctx.restore();
            }
            
            // Bomba plantada
            if (game.bombPlanted) {
                ctx.save();
                ctx.translate(bomb.x, bomb.y);
                
                const blink = Math.sin(game.time * bomb.blinkSpeed) > 0;
                if (blink) {
                    ctx.fillStyle = colors.bombGlow;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = colors.bombGlow;
                    ctx.fillRect(-15, -15, 30, 30);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí£', 0, 0);
                }
                
                if (game.bombTimer < 10) bomb.blinkSpeed = 0.3;
                else if (game.bombTimer < 20) bomb.blinkSpeed = 0.15;
                
                ctx.restore();
            }

            // Corpos
            ctx.globalAlpha = 0.5;
            corpses.forEach(corpse => {
                ctx.save();
                ctx.translate(corpse.x, corpse.y);
                ctx.rotate(corpse.angle + Math.PI / 2);
                ctx.fillStyle = '#330011';
                ctx.fillRect(-corpse.size/2, -corpse.size/2, corpse.size, corpse.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Part√≠culas
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = particle.color;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Inimigos
            enemies.forEach(enemy => enemy.draw());

            // Proj√©teis
            projectiles.forEach(projectile => projectile.draw());

            // Trail do jogador
            player.trail.forEach((point, index) => {
                ctx.globalAlpha = index / player.trail.length * 0.5;
                ctx.fillStyle = colors.player;
                ctx.save();
                ctx.translate(point.x, point.y);
                ctx.rotate(point.angle);
                ctx.fillRect(-player.size/3, -player.size/3, player.size/1.5, player.size/1.5);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Jogador
            ctx.save();
            ctx.translate(player.x, player.y);
            
            if (player.invulnerable % 10 < 5) {
                ctx.rotate(player.angle);
                ctx.shadowBlur = 20;
                ctx.shadowColor = player.color;
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.moveTo(player.size/2, 0);
                ctx.lineTo(-player.size/3, -player.size/3);
                ctx.lineTo(-player.size/2, 0);
                ctx.lineTo(-player.size/3, player.size/3);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(-2, -2, 8, 4);
                
                if (player.hasBomb) {
                    ctx.fillStyle = colors.bombGlow;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üí£', 0, -20);
                }
            }
            
            ctx.restore();
            
            // Sa√≠da do n√≠vel
            if (level && level.exit) {
                const canExit = (level.bombLocation && (game.bombPlanted || !player.hasBomb)) || 
                               (!level.bombLocation && enemies.length === 0);
                
                if (canExit) {
                    ctx.save();
                    ctx.fillStyle = colors.neonBlue;
                    ctx.strokeStyle = colors.neonBlue;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = colors.neonBlue;
                    ctx.lineWidth = 3;
                    
                    ctx.strokeRect(
                        level.exit.x - level.exit.width/2,
                        level.exit.y - level.exit.height/2,
                        level.exit.width,
                        level.exit.height
                    );
                    
                    ctx.globalAlpha = Math.sin(game.time * 0.05) * 0.3 + 0.3;
                    ctx.fillRect(
                        level.exit.x - level.exit.width/2,
                        level.exit.y - level.exit.height/2,
                        level.exit.width,
                        level.exit.height
                    );
                    
                    ctx.restore();
                }
            }
            
            // Restaura contexto antes de desenhar UI
            ctx.restore();
            
            // UI (n√£o afetada pela c√¢mera)
            if (level) {
                ctx.fillStyle = colors.neonPurple;
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'right';
                ctx.fillText(`N√çVEL ${game.currentLevel + 1}: ${level.name}`, canvas.width - 20, 40);
            }
            
            // Scanlines
            ctx.globalAlpha = 0.05;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            ctx.globalAlpha = 1;

            // Vinheta
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Inicializa
        loadLevel(0);
        game.cameraX = player.x;
        game.cameraY = player.y;
        gameLoop();
        
        // ========== ORIENTA√á√ïES PARA SPRITES ==========
        /*
        SPRITES NECESS√ÅRIOS PARA COMPLETAR O JOGO:
        
        1. PERSONAGEM PRINCIPAL (Mad Max) - J√Å IMPLEMENTADO ‚úÖ
           - madmax000-015.png (16 sprites)
        
        2. INIMIGOS (Janis) - PARCIALMENTE IMPLEMENTADO
           - janis000-015.png (16 sprites) 
           - janis2000-015.png (16 sprites)
           Voc√™ j√° tem esses arquivos, o c√≥digo tentar√° carreg√°-los automaticamente
        
        3. OBJETOS DE CEN√ÅRIO - NOVOS SPRITES NECESS√ÅRIOS:
           
           a) CARRO (car.png) - Sugest√£o 64x40 pixels
              - Vista top-down de um carro
              - Cores: cinza escuro (#444) com detalhes
              - Pode ter vers√µes destru√≠das (car_destroyed.png)
           
           b) POSTE DE LUZ (post.png) - Sugest√£o 32x32 pixels
              - C√≠rculo com luz amarela no topo
              - Base cinza escura
              - Efeito de brilho seria bom
           
           c) BARRIL EXPLOSIVO (barrel.png) - Sugest√£o 32x32 pixels
              - Barril vermelho/laranja
              - S√≠mbolo de perigo (‚ö†) ou caveira
              - Vers√£o explodida opcional
        
        4. EFEITOS ESPECIAIS (OPCIONAIS):
           - explosion_001-008.png - Anima√ß√£o de explos√£o
           - blood_splatter.png - Manchas de sangue
           - bullet_impact.png - Impacto de tiro
           - dash_trail.png - Rastro do dash
        
        5. TILES DO CEN√ÅRIO (OPCIONAIS):
           - asphalt.png - Textura do asfalto (32x32)
           - wall.png - Textura das paredes roxas (32x32)
           - crack001-003.png - Rachaduras no ch√£o
        
        6. UI ELEMENTS (OPCIONAIS):
           - heart_full.png - Cora√ß√£o cheio
           - heart_empty.png - Cora√ß√£o vazio
           - bomb_icon.png - √çcone da bomba
           - arrow.png - Seta indicadora
        
        COMO IMPLEMENTAR OS SPRITES:
        1. Crie os arquivos PNG com fundo transparente
        2. Coloque na mesma pasta do index.html
        3. O c√≥digo j√° tem fallback procedural se n√£o encontrar
        4. Para testar: abra o console (F12) e veja se carregou
        
        TAMANHOS RECOMENDADOS:
        - Personagens: 64x64 pixels
        - Objetos grandes: 64x40 pixels
        - Objetos pequenos: 32x32 pixels
        - Tiles: 32x32 pixels
        - UI: 24x24 pixels
        */
    </script>
</body>
</html>
