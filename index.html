<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Carnage - Prototype</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            filter: contrast(1.2) saturate(1.5);
        }
        
        #gameCanvas {
            border: 3px solid #ff0066;
            box-shadow: 0 0 30px #ff0066, inset 0 0 30px rgba(255, 0, 102, 0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 10px #ff0066, 0 0 20px #ff0066;
            font-weight: 900;
            letter-spacing: 2px;
        }
        
        .ui-bar {
            margin: 10px 0;
            width: 200px;
            height: 20px;
            border: 2px solid #ff0066;
            background: rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
        }
        
        .ui-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff00ff);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px currentColor;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0066;
            font-size: 72px;
            display: none;
            text-align: center;
            text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-align: center;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #audioControls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 14px;
        }
        
        #audioControls button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 5px #00ffff;
            margin-left: 10px;
        }
        
        #audioControls button:hover {
            background: rgba(0, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>VIDA</div>
            <div class="ui-bar">
                <div class="ui-bar-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div>PONTOS: <span id="score">0</span></div>
            <div style="font-size: 14px; margin-top: 20px; color: #00ffff;">
                COMBO: x<span id="combo">1</span>
            </div>
        </div>
        <div id="gameOver">
            MORREU VÉI<br>
            <span style="font-size: 24px">Pressione R para reiniciar</span>
        </div>
        <div id="instructions">
            WASD: MOVER | MOUSE: MIRAR | CLIQUE: ATIRAR | ESPAÇO: DASH/ATROPELAR
        </div>
        <div id="audioControls">
            <button onclick="toggleMusic()">🎵 MÚSICA</button>
        </div>
    </div>
    
    <!-- ADICIONE SUA MÚSICA AQUI -->
    <audio id="gameMusic" loop>
        <source src="musica.mp3" type="audio/mpeg">
        <source src="musica.ogg" type="audio/ogg">
        <!-- Adicione outros formatos se necessário -->
    </audio>

    <script>
        // Sistema de áudio
        const gameMusic = document.getElementById('gameMusic');
        gameMusic.volume = 0.5;  // Volume em 50%
        let musicStarted = false;
        
        function toggleMusic() {
            if (gameMusic.paused) {
                gameMusic.play().catch(e => console.log('Erro ao tocar música:', e));
            } else {
                gameMusic.pause();
            }
        }
        
        // Tenta tocar música no primeiro clique
        function startMusic() {
            if (!musicStarted) {
                musicStarted = true;
                gameMusic.play().catch(e => {
                    console.log('Música bloqueada pelo navegador. Clique no botão de música.');
                });
            }
        }
        
        // Adiciona listeners para iniciar música
        window.addEventListener('click', startMusic, { once: true });
        window.addEventListener('keydown', startMusic, { once: true });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 960;
        canvas.height = 640;

        // Configure melhor qualidade de renderização
        ctx.imageSmoothingEnabled = false;

        // Estado do jogo
        const game = {
            score: 0,
            combo: 1,
            comboTimer: 0,
            paused: false,
            over: false,
            screenShake: 0,
            time: 0,
            bloodParticles: [],
            deathRotation: 0,     // Rotação na morte
            deathRotationSpeed: 0.05, // Velocidade de rotação
            cameraX: 0,
            cameraY: 0,
            currentLevel: 0,  // Nível atual
            levelComplete: false
        };

        // Paleta de cores neon
        const colors = {
            player: '#00ff88',
            enemy: '#ff0066',
            bullet: '#ffff00',
            blood: ['#ff0066', '#cc0052', '#990039', '#660026'],
            wall: '#1a0033',
            floor: '#2a2a2a',  // Asfalto escuro
            neonBlue: '#00ffff',
            neonPink: '#ff00ff',
            neonPurple: '#9945ff',
            enemyGlow: '#ff00ff'  // Rosa neon vibrante
        };

        // Sistema de Sprites
        const sprites = {
            loaded: false,
            loadedCount: 0,
            totalSprites: 48,  // 16 mad max + 16 janis + 16 janis2
            player: {
                idle: [],      // Frames 0-3 (uma pose por direção)
                ride: [],      // Frames 4-7 e 0-3 alternando (pedalar)
                wheelie: [],   // Frames 8-11
                death: []      // Frames 12-15
            },
            enemies: {
                janis: {
                    idle: [],
                    ride: [],
                    wheelie: [],  // Armado quando vê o player
                    death: []
                },
                janis2: {
                    idle: [],
                    ride: [],
                    wheelie: [],  // Armado quando vê o player
                    death: []
                }
            }
        };

        // Carrega sprites do Mad Max
        function loadSprites() {
            console.log('🏍️ Preparando sprites...');
            
            // Como estamos no Claude, vamos criar sprites procedurais do Mad Max
            // Quando você testar localmente, os PNGs vão carregar
            
            // Cria sprites procedurais para cada ação
            const actions = ['idle', 'ride', 'wheelie', 'death'];
            const colors = {
                bike: '#333',
                rider: '#ff0066',
                wheel: '#222'
            };
            
            actions.forEach(action => {
                for (let dir = 0; dir < 4; dir++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.save();
                    ctx.translate(32, 32);
                    ctx.rotate(dir * Math.PI / 2);
                    
                    // Desenha bike
                    ctx.fillStyle = colors.bike;
                    if (action === 'wheelie') {
                        ctx.rotate(-0.3); // Inclina pra wheelie
                    }
                    
                    // Corpo da bike
                    ctx.fillRect(-20, -5, 40, 10);
                    
                    // Rodas
                    ctx.fillStyle = colors.wheel;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rider
                    ctx.fillStyle = colors.rider;
                    if (action === 'death') {
                        // Caído
                        ctx.fillRect(-5, -15, 10, 20);
                    } else {
                        // Em cima da bike
                        ctx.fillRect(-5, -10, 10, 15);
                        // Cabeça
                        ctx.beginPath();
                        ctx.arc(0, -10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    sprites.player[action][dir] = canvas;
                }
            });
            
            sprites.loaded = true;
            console.log('✅ Sprites procedurais criados!');
            
            // Função auxiliar para carregar imagens reais (para quando sair do Claude)
            function loadImage(src, category, index) {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    sprites.player[category][index] = img;
                    sprites.loadedCount++;
                    
                    if (sprites.loadedCount === sprites.totalSprites) {
                        console.log('✅ Sprites reais carregados!');
                    }
                };
                img.onerror = () => {
                    console.log(`⚠️ Usando sprite procedural para ${src}`);
                    sprites.loadedCount++;
                };
            }
            
            // Tenta carregar os PNGs reais (vai falhar no Claude, mas funciona local)
            const spritePath = './';
            
            // IDLE (Frames 0-3)
            loadImage(spritePath + 'madmax000.png', 'idle', 0);
            loadImage(spritePath + 'madmax001.png', 'idle', 1);
            loadImage(spritePath + 'madmax002.png', 'idle', 2);
            loadImage(spritePath + 'madmax003.png', 'idle', 3);
            
            // RIDE (Frames 4-7 são pé baixo, 0-3 são pé alto)
            // Organizamos como: [pé alto, pé baixo] para cada direção
            loadImage(spritePath + 'madmax000.png', 'ride', 0);  // Direita pé alto
            loadImage(spritePath + 'madmax004.png', 'ride', 1);  // Direita pé baixo
            loadImage(spritePath + 'madmax001.png', 'ride', 2);  // Baixo pé alto
            loadImage(spritePath + 'madmax005.png', 'ride', 3);  // Baixo pé baixo
            loadImage(spritePath + 'madmax002.png', 'ride', 4);  // Esquerda pé alto
            loadImage(spritePath + 'madmax006.png', 'ride', 5);  // Esquerda pé baixo
            loadImage(spritePath + 'madmax003.png', 'ride', 6);  // Cima pé alto
            loadImage(spritePath + 'madmax007.png', 'ride', 7);  // Cima pé baixo
            
            // WHEELIE (Frames 8-11)
            loadImage(spritePath + 'madmax008.png', 'wheelie', 0);
            loadImage(spritePath + 'madmax009.png', 'wheelie', 1);
            loadImage(spritePath + 'madmax010.png', 'wheelie', 2);
            loadImage(spritePath + 'madmax011.png', 'wheelie', 3);
            
            // DEATH (Frames 12-15)
            loadImage(spritePath + 'madmax012.png', 'death', 0);
            loadImage(spritePath + 'madmax013.png', 'death', 1);
            loadImage(spritePath + 'madmax014.png', 'death', 2);
            loadImage(spritePath + 'madmax015.png', 'death', 3);
            
            // Sprite do inimigo (temporário)
            const enemyCanvas = document.createElement('canvas');
            enemyCanvas.width = 64;
            enemyCanvas.height = 64;
            const eCtx = enemyCanvas.getContext('2d');
            
            eCtx.fillStyle = colors.enemy;
            eCtx.beginPath();
            eCtx.arc(32, 32, 20, 0, Math.PI * 2);
            eCtx.fill();
            
            eCtx.fillStyle = colors.enemy;
            eCtx.beginPath();
            eCtx.arc(32, 32, 20, 0, Math.PI * 2);
            eCtx.fill();
            
            sprites.enemy = enemyCanvas;
        }

        // Carrega sprites ao iniciar
        loadSprites();

        // Jogador
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 24,
            speed: 5,
            dashSpeed: 15,
            health: 3,
            maxHealth: 3,
            color: colors.player,
            attacking: false,
            attackCooldown: 0,
            invulnerable: 0,
            angle: 0,
            dashCooldown: 0,
            trail: [],
            sprite: null,
            frameTime: 0,
            currentAction: 'idle',  // idle, ride, wheelie, death
            direction: 0,          // 0=direita, 1=baixo, 2=esquerda, 3=cima
            isMoving: false,
            onBike: true,
            animFrame: 0,          // Frame atual da animação
            animTimer: 0           // Timer para trocar frames
        };

        // Controles
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };

        // Arrays do jogo
        const enemies = [];
        const projectiles = [];
        const particles = [];
        const corpses = [];

        // Sistema de níveis
        const levels = [
            {
                // Nível 1: Entrada
                name: "Entrada do Território",
                playerStart: { x: 100, y: 320 },
                exit: { x: 860, y: 320, width: 60, height: 100 },
                enemies: [],  // Sem inimigos no primeiro nível
                message: "Entre no território inimigo..."
            },
            {
                // Nível 2: Primeiro Confronto
                name: "Zona de Patrulha",
                playerStart: { x: 100, y: 320 },
                exit: { x: 860, y: 320, width: 60, height: 100 },
                enemies: [
                    { x: 400, y: 200, type: 'janis' },
                    { x: 600, y: 400, type: 'janis2' }
                ],
                message: "Cuidado! Guardas à frente!"
            }
        ];

        // Mapa melhorado
        const tileSize = 32;
        const mapWidth = Math.floor(canvas.width / tileSize);
        const mapHeight = Math.floor(canvas.height / tileSize);
        let map = [];

        // Função para gerar mapa do nível
        function generateLevelMap(levelIndex) {
            map = [];
            
            // Cria bordas
            for (let y = 0; y < mapHeight; y++) {
                map[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1) {
                        map[y][x] = 1;
                    } else {
                        map[y][x] = 0;
                    }
                }
            }
            
            // Adiciona obstáculos baseado no nível
            if (levelIndex === 0) {
                // Nível 1: Corredor simples
                for (let y = 5; y < mapHeight - 5; y++) {
                    if (y < 8 || y > 11) {
                        map[y][Math.floor(mapWidth / 2)] = 1;
                    }
                }
            } else {
                // Outros níveis: obstáculos aleatórios
                for (let i = 0; i < 10 + levelIndex * 3; i++) {
                    const x = Math.floor(Math.random() * (mapWidth - 4)) + 2;
                    const y = Math.floor(Math.random() * (mapHeight - 4)) + 2;
                    const w = Math.floor(Math.random() * 3) + 1;
                    const h = Math.floor(Math.random() * 3) + 1;
                    
                    for (let dy = 0; dy < h; dy++) {
                        for (let dx = 0; dx < w; dx++) {
                            if (x + dx < mapWidth - 1 && y + dy < mapHeight - 1) {
                                map[y + dy][x + dx] = 1;
                            }
                        }
                    }
                }
            }
        }

        // Inicializa o primeiro nível
        generateLevelMap(0);

        // Classe de inimigo melhorada
        class Enemy {
            constructor(x, y, type = 'janis') {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.speed = 2 + Math.random();
                this.health = 2;  // 2 hits para matar
                this.maxHealth = 2;
                this.color = '#ff00ff';  // FORÇA cor neon
                this.angle = 0;
                this.type = type;  // 'janis' ou 'janis2'
                this.behavior = Math.random() > 0.7 ? 'rusher' : 'normal';
                this.glowIntensity = 0;
                this.hitFlash = 0;
                this.active = false;
                this.detectionRange = 150;
                this.currentAction = 'idle';
                this.direction = 0;
                this.animFrame = 0;
                this.animTimer = 0;
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Verifica linha de visão antes de ativar
                const hasLineOfSight = this.checkLineOfSight(player.x, player.y);
                
                // Ativa inimigo quando player chega perto E tem linha de visão
                if (!this.active && distance < this.detectionRange && hasLineOfSight) {
                    this.active = true;
                    this.currentAction = 'wheelie'; // Fica armado!
                    createParticles(this.x, this.y, colors.neonPink, 10, 5);
                }
                
                // Atualiza direção
                if (dx > 0) this.direction = 0;      // Direita
                else if (dy > 0) this.direction = 1; // Baixo
                else if (dx < 0) this.direction = 2; // Esquerda
                else if (dy < 0) this.direction = 3; // Cima
                
                // Só se move se estiver ativo
                if (this.active && distance > 0) {
                    const moveSpeed = this.behavior === 'rusher' ? this.speed * 1.5 : this.speed;
                    
                    // Movimento com colisão
                    const nextX = this.x + (dx / distance) * moveSpeed;
                    const nextY = this.y + (dy / distance) * moveSpeed;
                    
                    // Verifica colisão com paredes
                    let moved = false;
                    if (!checkWallCollision(nextX, this.y, this.size)) {
                        this.x = nextX;
                        moved = true;
                    }
                    if (!checkWallCollision(this.x, nextY, this.size)) {
                        this.y = nextY;
                        moved = true;
                    }
                    
                    // Se está se movendo, anima
                    if (moved && this.active) {
                        this.currentAction = 'ride';
                        this.animTimer++;
                        if (this.animTimer > 6) {
                            this.animTimer = 0;
                            this.animFrame = (this.animFrame + 1) % 2;
                        }
                    } else if (this.active) {
                        this.currentAction = 'wheelie'; // Volta a ficar armado se parado
                    }
                    
                    this.angle = Math.atan2(dy, dx);
                }

                // Colisão com o jogador
                if (distance < this.size + player.size && player.invulnerable <= 0) {
                    player.health -= 1;  // Perde 1 vida por hit
                    player.invulnerable = 60;
                    game.screenShake = 10;
                    createBloodSplatter(player.x, player.y, 20);
                    
                    // Knockback
                    const knockbackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.x += Math.cos(knockbackAngle) * 20;
                    player.y += Math.sin(knockbackAngle) * 20;
                }

                this.glowIntensity = Math.sin(game.time * 0.1) * 0.5 + 0.5;
                if (this.hitFlash > 0) this.hitFlash--;
            }
            
            // Verifica linha de visão
            checkLineOfSight(targetX, targetY) {
                const steps = 20;
                const stepX = (targetX - this.x) / steps;
                const stepY = (targetY - this.y) / steps;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + stepX * i;
                    const checkY = this.y + stepY * i;
                    
                    const tileX = Math.floor(checkX / tileSize);
                    const tileY = Math.floor(checkY / tileSize);
                    
                    if (map[tileY] && map[tileY][tileX] === 1) {
                        return false; // Bloqueado por parede
                    }
                }
                
                return true; // Linha de visão limpa
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Tenta usar sprites do Janis
                if (sprites.loaded && sprites.enemies[this.type] && sprites.enemies[this.type][this.currentAction]) {
                    const spriteArray = sprites.enemies[this.type][this.currentAction];
                    let sprite;
                    
                    // Se está andando, usa animação
                    if (this.currentAction === 'ride') {
                        const frameIndex = this.direction * 2 + this.animFrame;
                        sprite = spriteArray[frameIndex] || spriteArray[this.direction];
                    } else {
                        sprite = spriteArray[this.direction];
                    }
                    
                    if (sprite && sprite.complete) {
                        // Flash quando atingido
                        if (this.hitFlash > 0) {
                            ctx.filter = 'brightness(2)';
                        }
                        
                        ctx.drawImage(sprite, -32, -32, 64, 64);
                        ctx.filter = 'none';
                    } else {
                        this.drawProcedural(); // Fallback
                    }
                } else {
                    this.drawProcedural(); // Fallback
                }
                
                ctx.restore();
            }
            
            drawProcedural() {
                // Desenho humanóide procedural NEON (fallback)
                // Glow effect MUITO FORTE
                ctx.shadowBlur = 30;
                ctx.shadowColor = colors.enemyGlow;
                
                // Flash quando atingido
                if (this.hitFlash > 0) {
                    ctx.fillStyle = '#ffffff';
                } else {
                    ctx.fillStyle = colors.enemyGlow;
                }
                
                // Corpo (tronco) - NEON
                ctx.fillRect(-8, -12, 16, 20);
                
                // Cabeça - NEON
                ctx.beginPath();
                ctx.arc(0, -12, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Braços - NEON
                ctx.fillRect(-12, -8, 4, 12);
                ctx.fillRect(8, -8, 4, 12);
                
                // Se está armado, desenha arma
                if (this.currentAction === 'wheelie') {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(10, -6, 15, 3);
                }
                
                // Pernas - NEON
                ctx.fillRect(-6, 8, 5, 10);
                ctx.fillRect(1, 8, 5, 10);
                
                // Olhos brilhantes (sempre visíveis)
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-3, -14, 2, 3);
                ctx.fillRect(1, -14, 2, 3);
                
                // Contorno NEON extra brilhante
                ctx.shadowBlur = 15;
                ctx.shadowColor = colors.neonPink;
                ctx.strokeStyle = colors.neonPink;
                ctx.lineWidth = 2;
                ctx.strokeRect(-8, -12, 16, 20);
                
                // Aura neon quando ativo
                if (this.active) {
                    ctx.globalAlpha = 0.5;
                    ctx.shadowBlur = 40;
                    ctx.strokeStyle = colors.neonBlue;
                    ctx.strokeRect(-12, -16, 24, 28);
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Função para verificar colisão com paredes
        function checkWallCollision(x, y, size) {
            // Verifica os 4 cantos da hitbox
            const corners = [
                { x: x - size/2, y: y - size/2 },
                { x: x + size/2, y: y - size/2 },
                { x: x - size/2, y: y + size/2 },
                { x: x + size/2, y: y + size/2 }
            ];
            
            for (let corner of corners) {
                const tileX = Math.floor(corner.x / tileSize);
                const tileY = Math.floor(corner.y / tileSize);
                
                if (map[tileY] && map[tileY][tileX] === 1) {
                    return true; // Colidiu
                }
            }
            
            return false; // Sem colisão
        }

        // Sistema de partículas melhorado
        function createParticles(x, y, color, count, speed = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed * (0.5 + Math.random()),
                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Sistema de sangue
        function createBloodSplatter(x, y, count) {
            for (let i = 0; i < count; i++) {
                game.bloodParticles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    size: Math.random() * 8 + 4,
                    color: colors.blood[Math.floor(Math.random() * colors.blood.length)]
                });
            }
        }

        // Projétil melhorado
        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.speed = 15;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 6;
                this.damage = 20;
                this.trail = [];
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                // Trail effect
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) {
                    this.trail.shift();
                }

                // Colisão com paredes
                const tileX = Math.floor(this.x / tileSize);
                const tileY = Math.floor(this.y / tileSize);
                if (map[tileY] && map[tileY][tileX] === 1) {
                    createParticles(this.x, this.y, colors.bullet, 5, 4);
                    return true;
                }

                // Colisão com inimigos
                let hit = false;
                enemies.forEach((enemy, index) => {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + this.size) {
                        enemy.health -= this.damage;
                        enemy.hitFlash = 5;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        
                        if (enemy.health <= 0) {
                            // Morte do inimigo
                            corpses.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: enemy.angle,
                                size: enemy.size,
                                color: enemy.color
                            });
                            
                            enemies.splice(index, 1);
                            game.score += 100 * game.combo;
                            game.combo = Math.min(game.combo + 1, 10);
                            game.comboTimer = 120;
                            createParticles(enemy.x, enemy.y, colors.neonPink, 20, 10);
                            game.screenShake = 8;
                        }
                        
                        hit = true;
                    }
                });
                
                return hit || this.life <= 0;
            }

            draw() {
                // Trail
                this.trail.forEach((point, index) => {
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.fillStyle = colors.bullet;
                    ctx.fillRect(point.x - 2, point.y - 2, 4, 4);
                });
                ctx.globalAlpha = 1;

                // Projétil com glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors.bullet;
                ctx.fillStyle = colors.bullet;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.shadowBlur = 0;
            }
        }

        // Carrega nível
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            
            // Reseta estado
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            game.bloodParticles.length = 0;
            game.levelComplete = false;
            
            // Posiciona jogador
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.health = player.maxHealth;
            
            // Gera mapa do nível
            generateLevelMap(levelIndex);
            
            // Spawna inimigos do nível
            level.enemies.forEach(enemyData => {
                const enemy = new Enemy(enemyData.x, enemyData.y, enemyData.type || 'janis');
                enemies.push(enemy);
            });
            
            // Mostra mensagem do nível
            console.log(`🎮 ${level.message}`);
        }

        // Spawn de inimigos melhorado (só em níveis específicos)
        function spawnEnemy() {
            // Só spawna automaticamente após nível 2
            if (game.currentLevel < 2) return;
            
            const spawnPoints = [];
            
            // Encontra pontos válidos de spawn
            for (let i = 0; i < 4; i++) {
                let x, y;
                const side = i;
                
                switch(side) {
                    case 0: x = Math.random() * canvas.width; y = 40; break;
                    case 1: x = canvas.width - 40; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height - 40; break;
                    case 3: x = 40; y = Math.random() * canvas.height; break;
                }
                
                spawnPoints.push({ x, y });
            }
            
            // Escolhe o ponto mais distante do jogador
            let bestPoint = spawnPoints[0];
            let maxDist = 0;
            
            spawnPoints.forEach(point => {
                const dist = Math.sqrt(Math.pow(point.x - player.x, 2) + Math.pow(point.y - player.y, 2));
                if (dist > maxDist) {
                    maxDist = dist;
                    bestPoint = point;
                }
            });
            
            enemies.push(new Enemy(bestPoint.x, bestPoint.y, Math.random() > 0.5 ? 'janis' : 'janis2'));
            createParticles(bestPoint.x, bestPoint.y, colors.neonPurple, 10, 5);
        }

        // Controles
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'r' && game.over) {
                resetGame();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.pressed = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.pressed = false;
        });

        // Reset do jogo
        function resetGame() {
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.trail = [];
            player.currentAction = 'idle';
            game.score = 0;
            game.combo = 1;
            game.over = false;
            game.screenShake = 0;
            game.deathRotation = 0;
            game.deathRotationSpeed = 0.05;
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            game.bloodParticles.length = 0;
            document.getElementById('gameOver').style.display = 'none';
        }

        // Game loop
        function update() {
            if (game.over) return;
            
            game.time++;

            // Movimento do jogador com colisão
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -1;
            if (keys['s'] || keys['arrowdown']) dy = 1;
            if (keys['a'] || keys['arrowleft']) dx = -1;
            if (keys['d'] || keys['arrowright']) dx = 1;
            
            // Atualiza direção baseada no movimento
            if (dx > 0) player.direction = 0;      // Direita
            else if (dy > 0) player.direction = 1; // Baixo
            else if (dx < 0) player.direction = 2; // Esquerda
            else if (dy < 0) player.direction = 3; // Cima
            
            // Normaliza movimento diagonal
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            // Verifica se está se movendo
            player.isMoving = (dx !== 0 || dy !== 0);
            
            // Define ação atual
            if (player.health <= 0) {
                player.currentAction = 'death';
            } else if (player.isMoving) {
                player.currentAction = 'ride';
            } else {
                player.currentAction = 'idle';
            }
            
            // Dash (Space) - Usa sprite de wheelie para atropelar
            let currentSpeed = player.speed;
            if (keys[' '] && player.dashCooldown <= 0 && player.onBike) {
                currentSpeed = player.dashSpeed;
                player.dashCooldown = 30;
                player.currentAction = 'wheelie'; // FORÇA animação de wheelie
                createParticles(player.x, player.y, colors.neonBlue, 10, 5);
                
                // Efeito visual do dash
                game.screenShake = 5;
                
                // Atropela inimigos durante dash
                enemies.forEach((enemy, index) => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + player.size + 10) {
                        enemy.health = 0;
                        corpses.push({
                            x: enemy.x,
                            y: enemy.y,
                            angle: enemy.angle,
                            size: enemy.size,
                            color: enemy.color
                        });
                        enemies.splice(index, 1);
                        game.score += 200 * game.combo;
                        game.combo = Math.min(game.combo + 1, 10);
                        game.comboTimer = 120;
                        createBloodSplatter(enemy.x, enemy.y, 30);
                        createParticles(enemy.x, enemy.y, colors.neonPink, 30, 12);
                        game.screenShake = 15;
                    }
                });
            }
            
            // Movimento com verificação de colisão
            const nextX = player.x + dx * currentSpeed;
            const nextY = player.y + dy * currentSpeed;
            
            if (!checkWallCollision(nextX, player.y, player.size)) {
                player.x = nextX;
            }
            if (!checkWallCollision(player.x, nextY, player.size)) {
                player.y = nextY;
            }
            
            if (player.dashCooldown > 0) {
                player.dashCooldown--;
                // Mantém sprite de wheelie durante o dash
                if (player.dashCooldown > 20) {
                    player.currentAction = 'wheelie';
                }
            }

            // Trail do jogador
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                player.trail.push({ 
                    x: player.x, 
                    y: player.y,
                    angle: player.angle
                });
                if (player.trail.length > 10) {
                    player.trail.shift();
                }
            }

            // Ângulo do jogador
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            // Limites da tela (removido - agora tem colisão com paredes)

            // Animação de pedalar
            if (player.currentAction === 'ride' && player.isMoving) {
                player.animTimer++;
                if (player.animTimer > 6) {  // Velocidade da pedalada ajustada
                    player.animTimer = 0;
                    player.animFrame = (player.animFrame + 1) % 2;  // Alterna entre 0 e 1
                }
            } else {
                player.animFrame = 0;
                player.animTimer = 0;
            }
            
            // Ataque
            if (mouse.pressed && player.attackCooldown <= 0) {
                projectiles.push(new Projectile(player.x, player.y, player.angle));
                player.attackCooldown = 8;
                game.screenShake = 3;
                
                // Recuo
                player.x -= Math.cos(player.angle) * 3;
                player.y -= Math.sin(player.angle) * 3;
            }
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            if (player.invulnerable > 0) player.invulnerable--;

            // Combo timer
            if (game.comboTimer > 0) {
                game.comboTimer--;
            } else {
                game.combo = 1;
            }

            // Screen shake decay
            if (game.screenShake > 0) game.screenShake *= 0.9;

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.update());

            // Atualiza projéteis
            projectiles.forEach((projectile, index) => {
                if (projectile.update()) {
                    projectiles.splice(index, 1);
                }
            });

            // Atualiza partículas
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Verifica se chegou na saída do nível
            const level = levels[game.currentLevel];
            if (level && level.exit) {
                const exitDx = player.x - level.exit.x;
                const exitDy = player.y - level.exit.y;
                
                if (Math.abs(exitDx) < level.exit.width/2 && 
                    Math.abs(exitDy) < level.exit.height/2 &&
                    enemies.length === 0) {  // Só pode sair se matou todos
                    
                    // Próximo nível!
                    game.currentLevel++;
                    if (game.currentLevel < levels.length) {
                        loadLevel(game.currentLevel);
                        createParticles(player.x, player.y, colors.neonBlue, 30, 10);
                    } else {
                        // Vitória! (por enquanto volta pro início)
                        game.currentLevel = 0;
                        loadLevel(0);
                    }
                }
            }
            
            // Spawn de inimigos (aumenta com o tempo)
            const spawnRate = game.currentLevel > 1 ? Math.min(0.02 + (game.time / 10000), 0.05) : 0;
            if (Math.random() < spawnRate) {
                spawnEnemy();
            }

            // Game over com ROTAÇÃO dramática
            if (player.health <= 0 && !game.over) {
                game.over = true;
                player.currentAction = 'death';
                // Define ponto focal na posição da morte
                game.cameraX = player.x;
                game.cameraY = player.y;
                // Cria explosão de partículas na morte
                createBloodSplatter(player.x, player.y, 50);
                createParticles(player.x, player.y, colors.enemy, 30, 15);
                game.screenShake = 20;
                
                // Inicia rotação
                game.deathRotation = 0;
                console.log('MORTE! Iniciando rotação');
                
                // Delay para mostrar game over
                setTimeout(() => {
                    document.getElementById('gameOver').style.display = 'block';
                }, 2000);
            }
            
            // Anima rotação da morte
            if (game.over) {
                game.deathRotation += game.deathRotationSpeed;
                // Desacelera a rotação
                if (game.deathRotationSpeed > 0.001) {
                    game.deathRotationSpeed *= 0.98;
                }
            }

            // Atualiza UI
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('score').textContent = game.score;
            document.getElementById('combo').textContent = game.combo;
        }

        function draw() {
            // Salva estado do canvas
            ctx.save();
            
            // ROTAÇÃO DRAMÁTICA NA MORTE
            if (game.over) {
                // Rotaciona em torno do centro da tela
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.rotate(game.deathRotation);
                ctx.translate(-canvas.width/2, -canvas.height/2);
                
                // Adiciona um leve zoom também
                const zoom = 1 + (game.deathRotation / 10);
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(zoom, zoom);
                ctx.translate(-game.cameraX, -game.cameraY);
            } else if (game.screenShake > 1) {
                // Screen shake normal (não na morte)
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }

            // Limpa canvas com cor de fundo
            ctx.fillStyle = colors.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Padrão de asfalto
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += tileSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += tileSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Marcações de asfalto (faixas)
            ctx.strokeStyle = '#444';
            ctx.setLineDash([20, 10]);
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Sangue no chão
            ctx.globalAlpha = 0.7;
            game.bloodParticles.forEach(blood => {
                ctx.fillStyle = blood.color;
                ctx.beginPath();
                ctx.arc(blood.x, blood.y, blood.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Desenha mapa/paredes
            ctx.shadowBlur = 10;
            ctx.shadowColor = colors.neonPurple;
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = colors.wall;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                        
                        // Borda neon
                        ctx.strokeStyle = colors.neonPurple;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            }
            ctx.shadowBlur = 0;

            // Desenha corpos
            ctx.globalAlpha = 0.5;
            corpses.forEach(corpse => {
                ctx.save();
                ctx.translate(corpse.x, corpse.y);
                ctx.rotate(corpse.angle + Math.PI / 2);
                ctx.fillStyle = '#330011';
                ctx.fillRect(-corpse.size/2, -corpse.size/2, corpse.size, corpse.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha partículas
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = particle.color;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Desenha inimigos
            enemies.forEach(enemy => enemy.draw());

            // Desenha projéteis
            projectiles.forEach(projectile => projectile.draw());

            // Desenha trail do jogador
            player.trail.forEach((point, index) => {
                ctx.globalAlpha = index / player.trail.length * 0.5;
                ctx.fillStyle = colors.player;
                ctx.save();
                ctx.translate(point.x, point.y);
                ctx.rotate(point.angle);
                ctx.fillRect(-player.size/3, -player.size/3, player.size/1.5, player.size/1.5);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha jogador
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Rotação suave para a mira (só visual, não afeta o sprite)
            const displayAngle = player.angle;
            
            // Pisca quando invulnerável
            if (player.invulnerable % 10 < 5) {
                // Se tem sprite do Mad Max, usa sprite
                if (sprites.loaded && sprites.player[player.currentAction]) {
                    const spriteArray = sprites.player[player.currentAction];
                    let sprite;
                    
                    // Se está pedalando, alterna entre frames
                    if (player.currentAction === 'ride' && player.isMoving) {
                        // Calcula índice: direção * 2 + frame de animação
                        const frameIndex = player.direction * 2 + player.animFrame;
                        sprite = spriteArray[frameIndex];
                    } else {
                        // Para outras ações, usa índice direto pela direção
                        sprite = spriteArray[player.direction];
                    }
                    
                    if (sprite && sprite.complete) {
                        // Desenha o sprite do Mad Max
                        ctx.drawImage(
                            sprite,
                            -32, -32,  // Centraliza o sprite de 64x64
                            64, 64
                        );
                    }
                } else {
                    // Fallback para desenho procedural
                    ctx.rotate(displayAngle);
                    
                    // Glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = player.color;
                    
                    // Corpo do jogador (design cyberpunk)
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.moveTo(player.size/2, 0);
                    ctx.lineTo(-player.size/3, -player.size/3);
                    ctx.lineTo(-player.size/2, 0);
                    ctx.lineTo(-player.size/3, player.size/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhe central
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-2, -2, 8, 4);
                }
                
                // NÃO desenha linha de mira no player quando tem sprite
            }
            
            ctx.restore();
            
            // Efeito de scanlines

            // Desenha saída do nível
            const level = levels[game.currentLevel];
            if (level && level.exit && enemies.length === 0) {  // Só mostra se matou todos
                ctx.save();
                ctx.fillStyle = colors.neonBlue;
                ctx.strokeStyle = colors.neonBlue;
                ctx.shadowBlur = 20;
                ctx.shadowColor = colors.neonBlue;
                ctx.lineWidth = 3;
                
                // Desenha portal de saída
                ctx.strokeRect(
                    level.exit.x - level.exit.width/2,
                    level.exit.y - level.exit.height/2,
                    level.exit.width,
                    level.exit.height
                );
                
                // Efeito pulsante
                ctx.globalAlpha = Math.sin(game.time * 0.05) * 0.3 + 0.3;
                ctx.fillRect(
                    level.exit.x - level.exit.width/2,
                    level.exit.y - level.exit.height/2,
                    level.exit.width,
                    level.exit.height
                );
                
                ctx.restore();
            }
            
            // UI do nível
            if (level) {
                ctx.fillStyle = colors.neonPurple;
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'right';
                ctx.fillText(`NÍVEL ${game.currentLevel + 1}: ${level.name}`, canvas.width - 20, 40);
                
                // UI de vida (só 3 corações)
                ctx.save();
                ctx.fillStyle = colors.neonPink;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('❤️'.repeat(player.health), 20, 90);
                ctx.restore();
                
                // Mensagem se precisa matar inimigos
                if (level.exit && enemies.length > 0) {
                    ctx.fillStyle = colors.enemy;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ELIMINE ${enemies.length} INIMIGO${enemies.length > 1 ? 'S' : ''}`, canvas.width/2, 60);
                }
            }
            
            // Efeito de scanlines
            ctx.globalAlpha = 0.05;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            ctx.globalAlpha = 1;

            // Vinheta
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Inicializa o jogo
        loadLevel(0);
        gameLoop();
    </script>
</body>
</html>
