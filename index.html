<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Carnage - Prototype</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            filter: contrast(1.2) saturate(1.5);
        }
        
        #gameCanvas {
            border: 3px solid #ff0066;
            box-shadow: 0 0 30px #ff0066, inset 0 0 30px rgba(255, 0, 102, 0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 10px #ff0066, 0 0 20px #ff0066;
            font-weight: 900;
            letter-spacing: 2px;
        }
        
        .ui-bar {
            margin: 10px 0;
            width: 200px;
            height: 20px;
            border: 2px solid #ff0066;
            background: rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
        }
        
        .ui-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff00ff);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px currentColor;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0066;
            font-size: 72px;
            display: none;
            text-align: center;
            text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-align: center;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div>VIDA</div>
            <div class="ui-bar">
                <div class="ui-bar-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div>PONTOS: <span id="score">0</span></div>
            <div style="font-size: 14px; margin-top: 20px; color: #00ffff;">
                COMBO: x<span id="combo">1</span>
            </div>
        </div>
        <div id="gameOver">
            GAME OVER<br>
            <span style="font-size: 24px">Pressione R para reiniciar</span>
        </div>
        <div id="instructions">
            WASD: MOVER | MOUSE: MIRAR | CLIQUE: ATIRAR | SHIFT: WHEELIE | ESPA√áO: DASH/ATROPELAR
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 960;
        canvas.height = 640;

        // Configure melhor qualidade de renderiza√ß√£o
        ctx.imageSmoothingEnabled = false;

        // Estado do jogo
        const game = {
            score: 0,
            combo: 1,
            comboTimer: 0,
            paused: false,
            over: false,
            screenShake: 0,
            time: 0,
            bloodParticles: [],
            deathZoom: 1,
            deathZoomTarget: 2.5,
            cameraX: 0,
            cameraY: 0
        };

        // Paleta de cores neon
        const colors = {
            player: '#00ff88',
            enemy: '#ff0066',
            bullet: '#ffff00',
            blood: ['#ff0066', '#cc0052', '#990039', '#660026'],
            wall: '#1a0033',
            floor: '#0d001a',
            neonBlue: '#00ffff',
            neonPink: '#ff00ff',
            neonPurple: '#9945ff'
        };

        // Sistema de Sprites
        const sprites = {
            loaded: false,
            loadedCount: 0,
            totalSprites: 16,
            player: {
                idle: [],      // Frames 0-3
                ride: [],      // Frames 4-7
                wheelie: [],   // Frames 8-11
                death: []      // Frames 12-15
            },
            enemy: null
        };

        // Carrega sprites do Mad Max
        function loadSprites() {
            console.log('üèçÔ∏è Preparando sprites...');
            
            // Como estamos no Claude, vamos criar sprites procedurais do Mad Max
            // Quando voc√™ testar localmente, os PNGs v√£o carregar
            
            // Cria sprites procedurais para cada a√ß√£o
            const actions = ['idle', 'ride', 'wheelie', 'death'];
            const colors = {
                bike: '#333',
                rider: '#ff0066',
                wheel: '#222'
            };
            
            actions.forEach(action => {
                for (let dir = 0; dir < 4; dir++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.save();
                    ctx.translate(32, 32);
                    ctx.rotate(dir * Math.PI / 2);
                    
                    // Desenha bike
                    ctx.fillStyle = colors.bike;
                    if (action === 'wheelie') {
                        ctx.rotate(-0.3); // Inclina pra wheelie
                    }
                    
                    // Corpo da bike
                    ctx.fillRect(-20, -5, 40, 10);
                    
                    // Rodas
                    ctx.fillStyle = colors.wheel;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rider
                    ctx.fillStyle = colors.rider;
                    if (action === 'death') {
                        // Ca√≠do
                        ctx.fillRect(-5, -15, 10, 20);
                    } else {
                        // Em cima da bike
                        ctx.fillRect(-5, -10, 10, 15);
                        // Cabe√ßa
                        ctx.beginPath();
                        ctx.arc(0, -10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    sprites.player[action][dir] = canvas;
                }
            });
            
            sprites.loaded = true;
            console.log('‚úÖ Sprites procedurais criados!');
            
            // Fun√ß√£o auxiliar para carregar imagens reais (para quando sair do Claude)
            function loadImage(src, category, index) {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    sprites.player[category][index] = img;
                    sprites.loadedCount++;
                    
                    if (sprites.loadedCount === sprites.totalSprites) {
                        console.log('‚úÖ Sprites reais carregados!');
                    }
                };
                img.onerror = () => {
                    console.log(`‚ö†Ô∏è Usando sprite procedural para ${src}`);
                    sprites.loadedCount++;
                };
            }
            
            // Tenta carregar os PNGs reais (vai falhar no Claude, mas funciona local)
            const spritePath = './';
            
            // IDLE (Frames 0-3)
            loadImage(spritePath + 'madmax000.png', 'idle', 0);
            loadImage(spritePath + 'madmax001.png', 'idle', 1);
            loadImage(spritePath + 'madmax002.png', 'idle', 2);
            loadImage(spritePath + 'madmax003.png', 'idle', 3);
            
            // RIDE (Frames 4-7)
            loadImage(spritePath + 'madmax004.png', 'ride', 0);
            loadImage(spritePath + 'madmax005.png', 'ride', 1);
            loadImage(spritePath + 'madmax006.png', 'ride', 2);
            loadImage(spritePath + 'madmax007.png', 'ride', 3);
            
            // WHEELIE (Frames 8-11)
            loadImage(spritePath + 'madmax008.png', 'wheelie', 0);
            loadImage(spritePath + 'madmax009.png', 'wheelie', 1);
            loadImage(spritePath + 'madmax010.png', 'wheelie', 2);
            loadImage(spritePath + 'madmax011.png', 'wheelie', 3);
            
            // DEATH (Frames 12-15)
            loadImage(spritePath + 'madmax012.png', 'death', 0);
            loadImage(spritePath + 'madmax013.png', 'death', 1);
            loadImage(spritePath + 'madmax014.png', 'death', 2);
            loadImage(spritePath + 'madmax015.png', 'death', 3);
            
            // Sprite do inimigo (tempor√°rio)
            const enemyCanvas = document.createElement('canvas');
            enemyCanvas.width = 64;
            enemyCanvas.height = 64;
            const eCtx = enemyCanvas.getContext('2d');
            
            eCtx.fillStyle = colors.enemy;
            eCtx.beginPath();
            eCtx.arc(32, 32, 20, 0, Math.PI * 2);
            eCtx.fill();
            
            sprites.enemy = enemyCanvas;
        }

        // Carrega sprites ao iniciar
        loadSprites();

        // Jogador
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 24,
            speed: 5,
            dashSpeed: 15,
            health: 100,
            maxHealth: 100,
            color: colors.player,
            attacking: false,
            attackCooldown: 0,
            invulnerable: 0,
            angle: 0,
            dashCooldown: 0,
            trail: [],
            sprite: null,
            frameTime: 0,
            currentAction: 'idle',  // idle, ride, wheelie, death
            direction: 0,          // 0=direita, 1=baixo, 2=esquerda, 3=cima
            isMoving: false,
            wheelieTime: 0,
            onBike: true
        };

        // Controles
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };

        // Arrays do jogo
        const enemies = [];
        const projectiles = [];
        const particles = [];
        const corpses = [];

        // Mapa melhorado
        const tileSize = 32;
        const mapWidth = Math.floor(canvas.width / tileSize);
        const mapHeight = Math.floor(canvas.height / tileSize);
        const map = [];

        // Gera mapa
        for (let y = 0; y < mapHeight; y++) {
            map[y] = [];
            for (let x = 0; x < mapWidth; x++) {
                if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1) {
                    map[y][x] = 1;
                } else {
                    map[y][x] = 0;
                }
            }
        }

        // Adiciona obst√°culos com design
        for (let i = 0; i < 15; i++) {
            const x = Math.floor(Math.random() * (mapWidth - 4)) + 2;
            const y = Math.floor(Math.random() * (mapHeight - 4)) + 2;
            const w = Math.floor(Math.random() * 3) + 1;
            const h = Math.floor(Math.random() * 3) + 1;
            
            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    if (x + dx < mapWidth - 1 && y + dy < mapHeight - 1) {
                        map[y + dy][x + dx] = 1;
                    }
                }
            }
        }

        // Classe de inimigo melhorada
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.speed = 2 + Math.random();
                this.health = 30;
                this.maxHealth = 30;
                this.color = colors.enemy;
                this.angle = 0;
                this.type = Math.random() > 0.7 ? 'rusher' : 'normal';
                this.glowIntensity = 0;
                this.hitFlash = 0;
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const moveSpeed = this.type === 'rusher' ? this.speed * 1.5 : this.speed;
                    this.x += (dx / distance) * moveSpeed;
                    this.y += (dy / distance) * moveSpeed;
                    this.angle = Math.atan2(dy, dx);
                }

                // Colis√£o com o jogador
                if (distance < this.size + player.size && player.invulnerable <= 0) {
                    player.health -= 10;
                    player.invulnerable = 60;
                    game.screenShake = 10;
                    createBloodSplatter(player.x, player.y, 20);
                    
                    // Knockback
                    const knockbackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.x += Math.cos(knockbackAngle) * 20;
                    player.y += Math.sin(knockbackAngle) * 20;
                }

                this.glowIntensity = Math.sin(game.time * 0.1) * 0.5 + 0.5;
                if (this.hitFlash > 0) this.hitFlash--;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Se tem sprite, usa sprite
                if (sprites.loaded && sprites.enemy) {
                    // Flash quando atingido
                    if (this.hitFlash > 0) {
                        ctx.filter = 'brightness(2)';
                    }
                    
                    ctx.drawImage(
                        sprites.enemy,
                        -32, -32, // Centraliza o sprite
                        64, 64
                    );
                    
                    ctx.filter = 'none';
                } else {
                    // Fallback para desenho procedural
                    // Glow effect
                    ctx.shadowBlur = 20 + this.glowIntensity * 10;
                    ctx.shadowColor = this.color;
                    
                    // Flash quando atingido
                    if (this.hitFlash > 0) {
                        ctx.fillStyle = '#ffffff';
                    } else {
                        ctx.fillStyle = this.color;
                    }
                    
                    // Corpo do inimigo (formato mais interessante)
                    ctx.beginPath();
                    ctx.moveTo(-this.size/2, -this.size/2);
                    ctx.lineTo(this.size/2, 0);
                    ctx.lineTo(-this.size/2, this.size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Olho
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupila
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(2, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Sistema de part√≠culas melhorado
        function createParticles(x, y, color, count, speed = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed * (0.5 + Math.random()),
                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Sistema de sangue
        function createBloodSplatter(x, y, count) {
            for (let i = 0; i < count; i++) {
                game.bloodParticles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    size: Math.random() * 8 + 4,
                    color: colors.blood[Math.floor(Math.random() * colors.blood.length)]
                });
            }
        }

        // Proj√©til melhorado
        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.speed = 15;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 6;
                this.damage = 20;
                this.trail = [];
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                // Trail effect
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) {
                    this.trail.shift();
                }

                // Colis√£o com paredes
                const tileX = Math.floor(this.x / tileSize);
                const tileY = Math.floor(this.y / tileSize);
                if (map[tileY] && map[tileY][tileX] === 1) {
                    createParticles(this.x, this.y, colors.bullet, 5, 4);
                    return true;
                }

                // Colis√£o com inimigos
                let hit = false;
                enemies.forEach((enemy, index) => {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + this.size) {
                        enemy.health -= this.damage;
                        enemy.hitFlash = 5;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        
                        if (enemy.health <= 0) {
                            // Morte do inimigo
                            corpses.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: enemy.angle,
                                size: enemy.size,
                                color: enemy.color
                            });
                            
                            enemies.splice(index, 1);
                            game.score += 100 * game.combo;
                            game.combo = Math.min(game.combo + 1, 10);
                            game.comboTimer = 120;
                            createParticles(enemy.x, enemy.y, colors.neonPink, 20, 10);
                            game.screenShake = 8;
                        }
                        
                        hit = true;
                    }
                });
                
                return hit || this.life <= 0;
            }

            draw() {
                // Trail
                this.trail.forEach((point, index) => {
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.fillStyle = colors.bullet;
                    ctx.fillRect(point.x - 2, point.y - 2, 4, 4);
                });
                ctx.globalAlpha = 1;

                // Proj√©til com glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors.bullet;
                ctx.fillStyle = colors.bullet;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.shadowBlur = 0;
            }
        }

        // Spawn de inimigos melhorado
        function spawnEnemy() {
            const spawnPoints = [];
            
            // Encontra pontos v√°lidos de spawn
            for (let i = 0; i < 4; i++) {
                let x, y;
                const side = i;
                
                switch(side) {
                    case 0: x = Math.random() * canvas.width; y = 40; break;
                    case 1: x = canvas.width - 40; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height - 40; break;
                    case 3: x = 40; y = Math.random() * canvas.height; break;
                }
                
                spawnPoints.push({ x, y });
            }
            
            // Escolhe o ponto mais distante do jogador
            let bestPoint = spawnPoints[0];
            let maxDist = 0;
            
            spawnPoints.forEach(point => {
                const dist = Math.sqrt(Math.pow(point.x - player.x, 2) + Math.pow(point.y - player.y, 2));
                if (dist > maxDist) {
                    maxDist = dist;
                    bestPoint = point;
                }
            });
            
            enemies.push(new Enemy(bestPoint.x, bestPoint.y));
            createParticles(bestPoint.x, bestPoint.y, colors.neonPurple, 10, 5);
        }

        // Controles
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'r' && game.over) {
                resetGame();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.pressed = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.pressed = false;
        });

        // Reset do jogo
        function resetGame() {
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.trail = [];
            player.currentAction = 'idle';
            player.wheelieTime = 0;
            game.score = 0;
            game.combo = 1;
            game.over = false;
            game.screenShake = 0;
            game.deathZoom = 1;
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            game.bloodParticles.length = 0;
            document.getElementById('gameOver').style.display = 'none';
        }

        // Game loop
        function update() {
            if (game.over) return;
            
            game.time++;

            // Movimento do jogador
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -1;
            if (keys['s'] || keys['arrowdown']) dy = 1;
            if (keys['a'] || keys['arrowleft']) dx = -1;
            if (keys['d'] || keys['arrowright']) dx = 1;
            
            // Atualiza dire√ß√£o baseada no movimento
            if (dx > 0) player.direction = 0;      // Direita
            else if (dy > 0) player.direction = 1; // Baixo
            else if (dx < 0) player.direction = 2; // Esquerda
            else if (dy < 0) player.direction = 3; // Cima
            
            // Normaliza movimento diagonal
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            // Verifica se est√° se movendo
            player.isMoving = (dx !== 0 || dy !== 0);
            
            // Wheelie (Shift segurando)
            if (keys['shift'] && player.onBike && player.isMoving) {
                player.currentAction = 'wheelie';
                player.wheelieTime++;
                currentSpeed = player.speed * 1.5; // Mais r√°pido no wheelie
                createParticles(player.x, player.y, colors.neonBlue, 2, 3);
            } else {
                if (player.wheelieTime > 0) {
                    // B√¥nus por wheelie longo
                    if (player.wheelieTime > 60) {
                        game.score += 50;
                        createParticles(player.x, player.y, colors.neonPink, 20, 8);
                    }
                }
                player.wheelieTime = 0;
                
                // Define a√ß√£o atual
                if (player.health <= 0) {
                    player.currentAction = 'death';
                } else if (player.isMoving) {
                    player.currentAction = 'ride';
                } else {
                    player.currentAction = 'idle';
                }
            }
            
            // Dash (Space)
            let currentSpeed = player.speed;
            if (keys[' '] && player.dashCooldown <= 0 && player.onBike) {
                currentSpeed = player.dashSpeed;
                player.dashCooldown = 30;
                createParticles(player.x, player.y, colors.player, 10, 5);
                
                // Atropela inimigos durante dash
                enemies.forEach((enemy, index) => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + player.size + 10) {
                        enemy.health = 0;
                        corpses.push({
                            x: enemy.x,
                            y: enemy.y,
                            angle: enemy.angle,
                            size: enemy.size,
                            color: enemy.color
                        });
                        enemies.splice(index, 1);
                        game.score += 200 * game.combo;
                        game.combo = Math.min(game.combo + 1, 10);
                        game.comboTimer = 120;
                        createBloodSplatter(enemy.x, enemy.y, 30);
                        createParticles(enemy.x, enemy.y, colors.neonPink, 30, 12);
                        game.screenShake = 15;
                    }
                });
            }
            
            player.x += dx * currentSpeed;
            player.y += dy * currentSpeed;
            
            if (player.dashCooldown > 0) player.dashCooldown--;

            // Trail do jogador
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                player.trail.push({ 
                    x: player.x, 
                    y: player.y,
                    angle: player.angle
                });
                if (player.trail.length > 10) {
                    player.trail.shift();
                }
            }

            // √Çngulo do jogador
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            // Limites da tela
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));

            // Ataque
            if (mouse.pressed && player.attackCooldown <= 0) {
                projectiles.push(new Projectile(player.x, player.y, player.angle));
                player.attackCooldown = 8;
                game.screenShake = 3;
                
                // Recuo
                player.x -= Math.cos(player.angle) * 3;
                player.y -= Math.sin(player.angle) * 3;
            }
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            if (player.invulnerable > 0) player.invulnerable--;

            // Combo timer
            if (game.comboTimer > 0) {
                game.comboTimer--;
            } else {
                game.combo = 1;
            }

            // Screen shake decay
            if (game.screenShake > 0) game.screenShake *= 0.9;

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.update());

            // Atualiza proj√©teis
            projectiles.forEach((projectile, index) => {
                if (projectile.update()) {
                    projectiles.splice(index, 1);
                }
            });

            // Atualiza part√≠culas
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Spawn de inimigos (aumenta com o tempo)
            const spawnRate = Math.min(0.02 + (game.time / 10000), 0.05);
            if (Math.random() < spawnRate) {
                spawnEnemy();
            }

            // Game over com zoom dram√°tico
            if (player.health <= 0 && !game.over) {
                game.over = true;
                player.currentAction = 'death';
                // Define ponto focal do zoom na posi√ß√£o da morte
                game.cameraX = player.x;
                game.cameraY = player.y;
                // Cria explos√£o de part√≠culas na morte
                createBloodSplatter(player.x, player.y, 50);
                createParticles(player.x, player.y, colors.enemy, 30, 15);
                
                // Delay para mostrar game over
                setTimeout(() => {
                    document.getElementById('gameOver').style.display = 'block';
                }, 2000);
            }
            
            // Anima zoom da morte
            if (game.over && game.deathZoom < game.deathZoomTarget) {
                game.deathZoom += 0.02;
            }

            // Atualiza UI
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('score').textContent = game.score;
            document.getElementById('combo').textContent = game.combo;
        }

        function draw() {
            // Salva estado do canvas
            ctx.save();
            
            // Aplica zoom dram√°tico na morte
            if (game.over) {
                // Calcula centro do zoom
                const zoomCenterX = game.cameraX;
                const zoomCenterY = game.cameraY;
                
                // Translada para o centro, aplica zoom, volta
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(game.deathZoom, game.deathZoom);
                ctx.translate(-zoomCenterX, -zoomCenterY);
            } else if (game.screenShake > 1) {
                // Screen shake normal (n√£o na morte)
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }

            // Limpa canvas com cor de fundo
            ctx.fillStyle = colors.floor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Padr√£o de piso
            ctx.strokeStyle = '#1a0033';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += tileSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += tileSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Sangue no ch√£o
            ctx.globalAlpha = 0.7;
            game.bloodParticles.forEach(blood => {
                ctx.fillStyle = blood.color;
                ctx.beginPath();
                ctx.arc(blood.x, blood.y, blood.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Desenha mapa/paredes
            ctx.shadowBlur = 10;
            ctx.shadowColor = colors.neonPurple;
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) {
                        ctx.fillStyle = colors.wall;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                        
                        // Borda neon
                        ctx.strokeStyle = colors.neonPurple;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            }
            ctx.shadowBlur = 0;

            // Desenha corpos
            ctx.globalAlpha = 0.5;
            corpses.forEach(corpse => {
                ctx.save();
                ctx.translate(corpse.x, corpse.y);
                ctx.rotate(corpse.angle + Math.PI / 2);
                ctx.fillStyle = '#330011';
                ctx.fillRect(-corpse.size/2, -corpse.size/2, corpse.size, corpse.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha part√≠culas
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = particle.color;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Desenha inimigos
            enemies.forEach(enemy => enemy.draw());

            // Desenha proj√©teis
            projectiles.forEach(projectile => projectile.draw());

            // Desenha trail do jogador
            player.trail.forEach((point, index) => {
                ctx.globalAlpha = index / player.trail.length * 0.5;
                ctx.fillStyle = colors.player;
                ctx.save();
                ctx.translate(point.x, point.y);
                ctx.rotate(point.angle);
                ctx.fillRect(-player.size/3, -player.size/3, player.size/1.5, player.size/1.5);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha jogador
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Rota√ß√£o suave para a mira (s√≥ visual, n√£o afeta o sprite)
            const displayAngle = player.angle;
            
            // Pisca quando invulner√°vel
            if (player.invulnerable % 10 < 5) {
                // Se tem sprite do Mad Max, usa sprite
                if (sprites.loaded && sprites.player[player.currentAction]) {
                    const spriteArray = sprites.player[player.currentAction];
                    const sprite = spriteArray[player.direction];
                    
                    if (sprite && sprite.complete) {
                        // Desenha o sprite do Mad Max
                        ctx.drawImage(
                            sprite,
                            -32, -32,  // Centraliza o sprite de 64x64
                            64, 64
                        );
                    }
                } else {
                    // Fallback para desenho procedural
                    ctx.rotate(displayAngle);
                    
                    // Glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = player.color;
                    
                    // Corpo do jogador (design cyberpunk)
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.moveTo(player.size/2, 0);
                    ctx.lineTo(-player.size/3, -player.size/3);
                    ctx.lineTo(-player.size/2, 0);
                    ctx.lineTo(-player.size/3, player.size/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhe central
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-2, -2, 8, 4);
                }
                
                // Linha de mira (sempre aparece)
                ctx.rotate(displayAngle);
                ctx.strokeStyle = colors.neonBlue;
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(player.size/2, 0);
                ctx.lineTo(player.size * 2, 0);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
            
            // UI do Wheelie
            if (player.currentAction === 'wheelie' && player.wheelieTime > 30) {
                ctx.fillStyle = colors.neonPink;
                ctx.font = 'bold 24px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors.neonPink;
                ctx.fillText('WHEELIE!', player.x, player.y - 50);
                ctx.shadowBlur = 0;
            }

            // Efeito de scanlines
            ctx.globalAlpha = 0.05;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            ctx.globalAlpha = 1;

            // Vinheta
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Inicia o jogo
        gameLoop();
    </script>
</body>
</html>
