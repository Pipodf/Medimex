        }<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Carnage - Prototype</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            filter: contrast(1.2) saturate(1.5);
        }
        
        #gameCanvas {
            border: 3px solid #ff0066;
            box-shadow: 0 0 30px #ff0066, inset 0 0 30px rgba(255, 0, 102, 0.3);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 0 0 10px #ff0066, 0 0 20px #ff0066;
            font-weight: 900;
            letter-spacing: 2px;
        }
        
        .ui-bar {
            display: none;  /* Esconde a barra de vida */
        }
        
        .ui-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff00ff);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px currentColor;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0066;
            font-size: 72px;
            display: none;
            text-align: center;
            text-shadow: 0 0 30px #ff0066, 0 0 60px #ff0066;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            text-align: center;
            font-size: 14px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #audioControls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 14px;
        }
        
        #audioControls button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            text-shadow: 0 0 5px #00ffff;
            margin-left: 10px;
        }
        
        #audioControls button:hover {
            background: rgba(0, 255, 255, 0.4);
        }
    </style>
</head>
            // Atualiza c√¢mera para seguir o player
            game.camera.x = player.x - game.camera.width / 2;
            game.camera.y = player.y - game.camera.height / 2;
            
            // Limita c√¢mera aos bounds do mundo
            game.camera.x = Math.max(0, Math.min(worldWidth - game.camera.width, game.camera.x));
            game.camera.y = Math.max(0, Math.min(worldHeight - game.camera.height, game.camera.y));
            
            // Atualiza debug info
            document.getElementById('debugLevel').textContent = game.currentLevel + 1;
            document.getElementById('debugEnemies').textContent = enemies.length;        #debugInfo {
            position: absolute;
            bottom: 50px;
            left: 20px;
            color: #ffffff;  /* Texto branco */
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #00ff00;
            max-width: 300px;
            text-shadow: 0 0 5px #00ff00;
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div style="font-size: 32px;">‚ù§Ô∏è<span style="opacity:0.3">‚ù§Ô∏è‚ù§Ô∏è</span></div>
            <div style="margin-top: 10px;">PONTOS: <span id="score">0</span></div>
            <div style="font-size: 14px; margin-top: 10px; color: #00ffff;">
                COMBO: x<span id="combo">1</span>
            </div>
        </div>
        <div id="gameOver">
            MORREU V√âI<br>
            <span style="font-size: 24px">Pressione R para reiniciar</span>
        </div>
        <div id="instructions">
            WASD: MOVER | MOUSE: MIRAR | CLIQUE: ATIRAR | ESPA√áO: DASH/ATROPELAR
        </div>
        <div id="audioControls">
            <button onclick="toggleMusic()">üéµ M√öSICA</button>
        </div>
        <div id="debugInfo">
            <div>Sprites carregados: <span id="debugSprites">0</span>/48</div>
            <div>N√≠vel: <span id="debugLevel">1</span></div>
            <div>Inimigos: <span id="debugEnemies">0</span></div>
        </div>
    </div>
    
    <!-- ADICIONE SUA M√öSICA AQUI -->
    <audio id="gameMusic" loop>
        <source src="musica.mp3" type="audio/mpeg">
        <source src="musica.ogg" type="audio/ogg">
        <!-- Adicione outros formatos se necess√°rio -->
    </audio>

    <script>
        // Sistema de √°udio FOR√áADO
        const gameMusic = document.getElementById('gameMusic');
        gameMusic.volume = 0.5;
        
        function toggleMusic() {
            if (gameMusic.paused) {
                gameMusic.play().catch(e => console.log('Erro:', e));
            } else {
                gameMusic.pause();
            }
        }
        
        // For√ßa tocar m√∫sica ap√≥s 1 segundo
        setTimeout(() => {
            gameMusic.play().catch(e => {
                console.log('M√∫sica bloqueada. Clique em qualquer lugar.');
                // Tenta novamente no primeiro clique
                document.addEventListener('click', () => {
                    gameMusic.play();
                }, { once: true });
            });
        }, 1000);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Canvas do tamanho da viewport
        canvas.width = 960;
        canvas.height = 640;
        
        // Mundo do jogo √© maior
        const worldWidth = 2880;  // 3x maior
        const worldHeight = 640;

        // Configure melhor qualidade de renderiza√ß√£o
        ctx.imageSmoothingEnabled = false;

        // Estado do jogo
        const game = {
            score: 0,
            combo: 1,
            comboTimer: 0,
            paused: false,
            over: false,
            screenShake: 0,
            time: 0,
            bloodParticles: [],
            deathRotation: 0,     // Rota√ß√£o na morte
            deathRotationSpeed: 0.05, // Velocidade de rota√ß√£o
            cameraX: 0,
            cameraY: 0,
            currentLevel: 0,  // N√≠vel atual
            levelComplete: false,
            camera: {  // Sistema de c√¢mera
                x: 0,
                y: 0,
                width: 960,  // √Årea vis√≠vel (tamanho original)
                height: 640
            }
        };

        // Paleta de cores neon
        const colors = {
            player: '#00ff88',
            enemy: '#ff0066',
            bullet: '#ffff00',
            blood: ['#ff0066', '#cc0052', '#990039', '#660026'],
            wall: '#1a0033',
            floor: '#2a2a2a',  // Asfalto escuro
            neonBlue: '#00ffff',
            neonPink: '#ff00ff',
            neonPurple: '#9945ff',
            enemyGlow: '#ff00ff'  // Rosa neon vibrante
        };

        // Sistema de Sprites
        const sprites = {
            loaded: false,
            loadedCount: 0,
            totalSprites: 48,  // 16 mad max + 16 janis + 16 janis2
            player: {
                idle: [],      // Frames 0-3 (uma pose por dire√ß√£o)
                ride: [],      // Frames 4-7 e 0-3 alternando (pedalar)
                wheelie: [],   // Frames 8-11
                death: []      // Frames 12-15
            },
            enemies: {
                janis: {
                    idle: [],
                    ride: [],
                    wheelie: [],  // Armado quando v√™ o player
                    death: []
                },
                janis2: {
                    idle: [],
                    ride: [],
                    wheelie: [],  // Armado quando v√™ o player
                    death: []
                }
            }
        };

        // Carrega sprites do Mad Max
        function loadSprites() {
            console.log('üèçÔ∏è Preparando sprites...');
            
            // Como estamos no Claude, vamos criar sprites procedurais do Mad Max
            // Quando voc√™ testar localmente, os PNGs v√£o carregar
            
            // Cria sprites procedurais para cada a√ß√£o
            const actions = ['idle', 'ride', 'wheelie', 'death'];
            const colors = {
                bike: '#333',
                rider: '#ff0066',
                wheel: '#222'
            };
            
            actions.forEach(action => {
                for (let dir = 0; dir < 4; dir++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.save();
                    ctx.translate(32, 32);
                    ctx.rotate(dir * Math.PI / 2);
                    
                    // Desenha bike
                    ctx.fillStyle = colors.bike;
                    if (action === 'wheelie') {
                        ctx.rotate(-0.3); // Inclina pra wheelie
                    }
                    
                    // Corpo da bike
                    ctx.fillRect(-20, -5, 40, 10);
                    
                    // Rodas
                    ctx.fillStyle = colors.wheel;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(15, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rider
                    ctx.fillStyle = colors.rider;
                    if (action === 'death') {
                        // Ca√≠do
                        ctx.fillRect(-5, -15, 10, 20);
                    } else {
                        // Em cima da bike
                        ctx.fillRect(-5, -10, 10, 15);
                        // Cabe√ßa
                        ctx.beginPath();
                        ctx.arc(0, -10, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    sprites.player[action][dir] = canvas;
                }
            });
            
            sprites.loaded = true;
            console.log('‚úÖ Sprites procedurais criados!');
            
            // Fun√ß√£o auxiliar para carregar imagens reais (para quando sair do Claude)
            function loadImage(src, category, index) {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    sprites.player[category][index] = img;
                    sprites.loadedCount++;
                    document.getElementById('debugSprites').textContent = sprites.loadedCount;
                    
                    if (sprites.loadedCount === sprites.totalSprites) {
                        console.log('‚úÖ Sprites reais carregados!');
                    }
                };
                img.onerror = () => {
                    console.log(`‚ö†Ô∏è Usando sprite procedural para ${src}`);
                    sprites.loadedCount++;
                    document.getElementById('debugSprites').textContent = sprites.loadedCount;
                };
            }
            
            // Tenta carregar os PNGs reais (vai falhar no Claude, mas funciona local)
            const spritePath = './';
            
            // IDLE (Frames 0-3)
            loadImage(spritePath + 'madmax000.png', 'idle', 0);
            loadImage(spritePath + 'madmax001.png', 'idle', 1);
            loadImage(spritePath + 'madmax002.png', 'idle', 2);
            loadImage(spritePath + 'madmax003.png', 'idle', 3);
            
            // RIDE (Frames 4-7 s√£o p√© baixo, 0-3 s√£o p√© alto)
            // Organizamos como: [p√© alto, p√© baixo] para cada dire√ß√£o
            loadImage(spritePath + 'madmax000.png', 'ride', 0);  // Direita p√© alto
            loadImage(spritePath + 'madmax004.png', 'ride', 1);  // Direita p√© baixo
            loadImage(spritePath + 'madmax001.png', 'ride', 2);  // Baixo p√© alto
            loadImage(spritePath + 'madmax005.png', 'ride', 3);  // Baixo p√© baixo
            loadImage(spritePath + 'madmax002.png', 'ride', 4);  // Esquerda p√© alto
            loadImage(spritePath + 'madmax006.png', 'ride', 5);  // Esquerda p√© baixo
            loadImage(spritePath + 'madmax003.png', 'ride', 6);  // Cima p√© alto
            loadImage(spritePath + 'madmax007.png', 'ride', 7);  // Cima p√© baixo
            
            // WHEELIE (Frames 8-11)
            loadImage(spritePath + 'madmax008.png', 'wheelie', 0);
            loadImage(spritePath + 'madmax009.png', 'wheelie', 1);
            loadImage(spritePath + 'madmax010.png', 'wheelie', 2);
            loadImage(spritePath + 'madmax011.png', 'wheelie', 3);
            
            // DEATH (Frames 12-15)
            loadImage(spritePath + 'madmax012.png', 'death', 0);
            loadImage(spritePath + 'madmax013.png', 'death', 1);
            loadImage(spritePath + 'madmax014.png', 'death', 2);
            loadImage(spritePath + 'madmax015.png', 'death', 3);
            
            // Sprite do inimigo (tempor√°rio)
            const enemyCanvas = document.createElement('canvas');
            enemyCanvas.width = 64;
            enemyCanvas.height = 64;
            const eCtx = enemyCanvas.getContext('2d');
            
            eCtx.fillStyle = colors.enemy;
            eCtx.beginPath();
            eCtx.arc(32, 32, 20, 0, Math.PI * 2);
            eCtx.fill();
            
            eCtx.fillStyle = colors.enemy;
            eCtx.beginPath();
            eCtx.arc(32, 32, 20, 0, Math.PI * 2);
            eCtx.fill();
            
            sprites.enemy = enemyCanvas;
        }

        // Carrega sprites ao iniciar
        loadSprites();

        // Jogador
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 24,
            speed: 7,  // Aumentado de 5 para 7
            dashSpeed: 20,  // Aumentado de 15 para 20
            health: 3,
            maxHealth: 3,
            color: colors.player,
            attacking: false,
            attackCooldown: 0,
            invulnerable: 0,
            angle: 0,
            dashCooldown: 0,
            trail: [],
            sprite: null,
            frameTime: 0,
            currentAction: 'idle',  // idle, ride, wheelie, death
            direction: 0,          // 0=direita, 1=baixo, 2=esquerda, 3=cima
            isMoving: false,
            onBike: true,
            animFrame: 0,          // Frame atual da anima√ß√£o
            animTimer: 0           // Timer para trocar frames
        };

        // Controles
        const keys = {};
        const mouse = { x: 0, y: 0, pressed: false };

        // Arrays do jogo
        const enemies = [];
        const projectiles = [];
        const particles = [];
        const corpses = [];

        // Sistema de n√≠veis
        const levels = [
            {
                // N√≠vel 1: Entrada
                name: "Entrada do Territ√≥rio",
                playerStart: { x: 100, y: 320 },
                exit: { x: 2760, y: 320, width: 60, height: 100 },  // Sa√≠da no final
                enemies: [],  // Sem inimigos no primeiro n√≠vel
                message: "Entre no territ√≥rio inimigo..."
            },
            {
                // N√≠vel 2: Primeiro Confronto
                name: "Zona de Patrulha",
                playerStart: { x: 100, y: 320 },
                exit: { x: 2760, y: 320, width: 60, height: 100 },  // Sa√≠da no final do mapa largo
                enemies: [
                    { x: 800, y: 200, type: 'janis' },
                    { x: 1600, y: 400, type: 'janis2' },
                    { x: 2400, y: 300, type: 'janis' }
                ],
                message: "Cuidado! Guardas √† frente!"
            }
        ];

        // Mapa melhorado
        const tileSize = 32;
        const mapWidth = Math.floor(worldWidth / tileSize);
        const mapHeight = Math.floor(worldHeight / tileSize);
        let map = [];

        // Fun√ß√£o para gerar mapa do n√≠vel
        function generateLevelMap(levelIndex) {
            map = [];
            
            // Cria bordas
            for (let y = 0; y < mapHeight; y++) {
                map[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1) {
                        map[y][x] = 1;
                    } else {
                        map[y][x] = 0;
                    }
                }
            }
            
            // Adiciona obst√°culos baseado no n√≠vel (evitando spawn de personagens)
            if (levelIndex === 0) {
                // N√≠vel 1: Corredor simples
                for (let y = 5; y < mapHeight - 5; y++) {
                    if (y < 8 || y > 11) {
                        map[y][Math.floor(mapWidth / 3)] = 1;
                        map[y][Math.floor(2 * mapWidth / 3)] = 1;
                    }
                }
            } else {
                // Outros n√≠veis: obst√°culos aleat√≥rios (longe dos spawns)
                for (let i = 0; i < 20 + levelIndex * 5; i++) {
                    const x = Math.floor(Math.random() * (mapWidth - 8)) + 4;
                    const y = Math.floor(Math.random() * (mapHeight - 8)) + 4;
                    const w = Math.floor(Math.random() * 2) + 1;
                    const h = Math.floor(Math.random() * 2) + 1;
                    
                    // Evita colocar perto dos spawns conhecidos
                    let tooClose = false;
                    levels[levelIndex].enemies.forEach(enemy => {
                        const dist = Math.sqrt(Math.pow(x * tileSize - enemy.x, 2) + Math.pow(y * tileSize - enemy.y, 2));
                        if (dist < 100) tooClose = true;
                    });
                    
                    if (!tooClose) {
                        for (let dy = 0; dy < h; dy++) {
                            for (let dx = 0; dx < w; dx++) {
                                if (x + dx < mapWidth - 1 && y + dy < mapHeight - 1) {
                                    map[y + dy][x + dx] = 1;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Inicializa o primeiro n√≠vel
        generateLevelMap(0);

        // Classe de inimigo melhorada
        class Enemy {
            constructor(x, y, type = 'janis') {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.speed = 2 + Math.random();
                this.health = 2;  // 2 hits para matar
                this.maxHealth = 2;
                this.color = '#ff00ff';  // FOR√áA cor neon
                this.angle = 0;
                this.type = type;  // 'janis' ou 'janis2'
                this.behavior = Math.random() > 0.5 ? 'patrol' : 'normal';  // Patrulha ou normal
                this.glowIntensity = 0;
                this.hitFlash = 0;
                this.active = false;
                this.detectionRange = 150;
                this.currentAction = 'idle';
                this.direction = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.visionAngle = Math.PI / 3;  // 60 graus de vis√£o
                
                // Para patrulha
                this.patrolPath = [];
                this.patrolIndex = 0;
                if (this.behavior === 'patrol') {
                    this.createPatrolPath();
                }
            }
            
            createPatrolPath() {
                // Cria um caminho de patrulha simples
                const centerX = this.x;
                const centerY = this.y;
                const radius = 100;
                
                this.patrolPath = [
                    { x: centerX + radius, y: centerY },
                    { x: centerX, y: centerY + radius },
                    { x: centerX - radius, y: centerY },
                    { x: centerX, y: centerY - radius }
                ];
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Verifica se player est√° no cone de vis√£o
                const angleToPlayer = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angleToPlayer - this.angle);
                const inVisionCone = angleDiff < this.visionAngle / 2 && distance < this.detectionRange;
                
                // Verifica linha de vis√£o
                const hasLineOfSight = this.checkLineOfSight(player.x, player.y);
                
                // Ativa quando v√™ o player
                if (!this.active && inVisionCone && hasLineOfSight) {
                    this.active = true;
                    this.currentAction = 'wheelie'; // Fica armado!
                    createParticles(this.x, this.y, colors.neonPink, 10, 5);
                }
                
                // Se est√° patrulhando e n√£o viu o player
                if (this.behavior === 'patrol' && !this.active) {
                    const target = this.patrolPath[this.patrolIndex];
                    const pdx = target.x - this.x;
                    const pdy = target.y - this.y;
                    const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                    
                    if (pdist < 10) {
                        // Chegou no ponto, vai pro pr√≥ximo
                        this.patrolIndex = (this.patrolIndex + 1) % this.patrolPath.length;
                    } else {
                        // Move para o ponto
                        this.x += (pdx / pdist) * this.speed * 0.5;
                        this.y += (pdy / pdist) * this.speed * 0.5;
                        this.angle = Math.atan2(pdy, pdx);
                        this.currentAction = 'ride';
                        
                        // Anima
                        this.animTimer++;
                        if (this.animTimer > 6) {
                            this.animTimer = 0;
                            this.animFrame = (this.animFrame + 1) % 2;
                        }
                    }
                }
                
                // Atualiza dire√ß√£o baseado no √¢ngulo
                if (this.angle > -Math.PI/4 && this.angle <= Math.PI/4) this.direction = 0; // Direita
                else if (this.angle > Math.PI/4 && this.angle <= 3*Math.PI/4) this.direction = 1; // Baixo
                else if (this.angle > 3*Math.PI/4 || this.angle <= -3*Math.PI/4) this.direction = 2; // Esquerda
                else this.direction = 3; // Cima
                
                // Persegue se est√° ativo
                if (this.active && distance > 0) {
                    const moveSpeed = this.speed;
                    
                    // Movimento com colis√£o
                    const nextX = this.x + (dx / distance) * moveSpeed;
                    const nextY = this.y + (dy / distance) * moveSpeed;
                    
                    // Verifica colis√£o com paredes
                    let moved = false;
                    if (!checkWallCollision(nextX, this.y, this.size)) {
                        this.x = nextX;
                        moved = true;
                    }
                    if (!checkWallCollision(this.x, nextY, this.size)) {
                        this.y = nextY;
                        moved = true;
                    }
                    
                    // Se est√° se movendo, anima
                    if (moved && this.active) {
                        this.currentAction = 'ride';
                        this.animTimer++;
                        if (this.animTimer > 6) {
                            this.animTimer = 0;
                            this.animFrame = (this.animFrame + 1) % 2;
                        }
                    } else if (this.active) {
                        this.currentAction = 'wheelie'; // Volta a ficar armado se parado
                    }
                    
                    this.angle = Math.atan2(dy, dx);
                }

                // Colis√£o com o jogador
                if (distance < this.size + player.size && player.invulnerable <= 0) {
                    player.health -= 1;  // Perde 1 vida por hit
                    player.invulnerable = 60;
                    game.screenShake = 10;
                    createBloodSplatter(player.x, player.y, 20);
                    
                    // Knockback
                    const knockbackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    player.x += Math.cos(knockbackAngle) * 20;
                    player.y += Math.sin(knockbackAngle) * 20;
                }

                this.glowIntensity = Math.sin(game.time * 0.1) * 0.5 + 0.5;
                if (this.hitFlash > 0) this.hitFlash--;
            }
            
            // Verifica linha de vis√£o
            checkLineOfSight(targetX, targetY) {
                const steps = 20;
                const stepX = (targetX - this.x) / steps;
                const stepY = (targetY - this.y) / steps;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + stepX * i;
                    const checkY = this.y + stepY * i;
                    
                    const tileX = Math.floor(checkX / tileSize);
                    const tileY = Math.floor(checkY / tileSize);
                    
                    if (map[tileY] && map[tileY][tileX] === 1) {
                        return false; // Bloqueado por parede
                    }
                }
                
                return true; // Linha de vis√£o limpa
            }

            draw() {
                // Primeiro desenha o cone de vis√£o
                if (!this.active) {
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    ctx.fillStyle = '#ff0066';
                    ctx.strokeStyle = '#ff0066';
                    ctx.lineWidth = 1;
                    
                    // Desenha cone de vis√£o
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const leftAngle = this.angle - this.visionAngle / 2;
                    const rightAngle = this.angle + this.visionAngle / 2;
                    ctx.arc(this.x, this.y, this.detectionRange, leftAngle, rightAngle);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Depois desenha o inimigo
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Tenta usar sprites do Janis
                if (sprites.loaded && sprites.enemies[this.type] && sprites.enemies[this.type][this.currentAction]) {
                    const spriteArray = sprites.enemies[this.type][this.currentAction];
                    let sprite;
                    
                    // Se est√° andando, usa anima√ß√£o
                    if (this.currentAction === 'ride') {
                        const frameIndex = this.direction * 2 + this.animFrame;
                        sprite = spriteArray[frameIndex] || spriteArray[this.direction];
                    } else {
                        sprite = spriteArray[this.direction];
                    }
                    
                    if (sprite && sprite.complete) {
                        // Flash quando atingido
                        if (this.hitFlash > 0) {
                            ctx.filter = 'brightness(2)';
                        }
                        
                        ctx.drawImage(sprite, -32, -32, 64, 64);
                        ctx.filter = 'none';
                    } else {
                        this.drawProcedural(); // Fallback
                    }
                } else {
                    this.drawProcedural(); // Fallback
                }
                
                ctx.restore();
            }
            
            drawProcedural() {
                // Desenho human√≥ide procedural NEON (fallback)
                // Glow effect MUITO FORTE
                ctx.shadowBlur = 30;
                ctx.shadowColor = colors.enemyGlow;
                
                // Flash quando atingido
                if (this.hitFlash > 0) {
                    ctx.fillStyle = '#ffffff';
                } else {
                    ctx.fillStyle = colors.enemyGlow;
                }
                
                // Corpo (tronco) - NEON
                ctx.fillRect(-8, -12, 16, 20);
                
                // Cabe√ßa - NEON
                ctx.beginPath();
                ctx.arc(0, -12, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Bra√ßos - NEON
                ctx.fillRect(-12, -8, 4, 12);
                ctx.fillRect(8, -8, 4, 12);
                
                // Se est√° armado, desenha arma
                if (this.currentAction === 'wheelie') {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(10, -6, 15, 3);
                }
                
                // Pernas - NEON
                ctx.fillRect(-6, 8, 5, 10);
                ctx.fillRect(1, 8, 5, 10);
                
                // Olhos brilhantes (sempre vis√≠veis)
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-3, -14, 2, 3);
                ctx.fillRect(1, -14, 2, 3);
                
                // Contorno NEON extra brilhante
                ctx.shadowBlur = 15;
                ctx.shadowColor = colors.neonPink;
                ctx.strokeStyle = colors.neonPink;
                ctx.lineWidth = 2;
                ctx.strokeRect(-8, -12, 16, 20);
                
                // Aura neon quando ativo
                if (this.active) {
                    ctx.globalAlpha = 0.5;
                    ctx.shadowBlur = 40;
                    ctx.strokeStyle = colors.neonBlue;
                    ctx.strokeRect(-12, -16, 24, 28);
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Fun√ß√£o para verificar colis√£o com paredes
        function checkWallCollision(x, y, size) {
            // Verifica os 4 cantos da hitbox
            const corners = [
                { x: x - size/2, y: y - size/2 },
                { x: x + size/2, y: y - size/2 },
                { x: x - size/2, y: y + size/2 },
                { x: x + size/2, y: y + size/2 }
            ];
            
            for (let corner of corners) {
                const tileX = Math.floor(corner.x / tileSize);
                const tileY = Math.floor(corner.y / tileSize);
                
                if (map[tileY] && map[tileY][tileX] === 1) {
                    return true; // Colidiu
                }
            }
            
            return false; // Sem colis√£o
        }

        // Sistema de part√≠culas melhorado
        function createParticles(x, y, color, count, speed = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed * (0.5 + Math.random()),
                    vy: Math.sin(angle) * speed * (0.5 + Math.random()),
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // Sistema de sangue
        function createBloodSplatter(x, y, count) {
            for (let i = 0; i < count; i++) {
                game.bloodParticles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    size: Math.random() * 8 + 4,
                    color: colors.blood[Math.floor(Math.random() * colors.blood.length)]
                });
            }
        }

        // Proj√©til melhorado
        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.speed = 15;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 6;
                this.damage = 20;
                this.trail = [];
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                // Trail effect
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) {
                    this.trail.shift();
                }

                // Colis√£o com paredes
                const tileX = Math.floor(this.x / tileSize);
                const tileY = Math.floor(this.y / tileSize);
                if (map[tileY] && map[tileY][tileX] === 1) {
                    createParticles(this.x, this.y, colors.bullet, 5, 4);
                    return true;
                }

                // Colis√£o com inimigos
                let hit = false;
                enemies.forEach((enemy, index) => {
                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + this.size) {
                        enemy.health -= this.damage;
                        enemy.hitFlash = 5;
                        createParticles(enemy.x, enemy.y, enemy.color, 8);
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        
                        if (enemy.health <= 0) {
                            // Morte do inimigo
                            corpses.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: enemy.angle,
                                size: enemy.size,
                                color: enemy.color
                            });
                            
                            enemies.splice(index, 1);
                            game.score += 100 * game.combo;
                            game.combo = Math.min(game.combo + 1, 10);
                            game.comboTimer = 120;
                            createParticles(enemy.x, enemy.y, colors.neonPink, 20, 10);
                            game.screenShake = 8;
                        }
                        
                        hit = true;
                    }
                });
                
                return hit || this.life <= 0;
            }

            draw() {
                // Trail
                this.trail.forEach((point, index) => {
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.fillStyle = colors.bullet;
                    ctx.fillRect(point.x - 2, point.y - 2, 4, 4);
                });
                ctx.globalAlpha = 1;

                // Proj√©til com glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = colors.bullet;
                ctx.fillStyle = colors.bullet;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.shadowBlur = 0;
            }
        }

        // Carrega n√≠vel
        function loadLevel(levelIndex) {
            const level = levels[levelIndex];
            
            // Reseta estado
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            game.bloodParticles.length = 0;
            game.levelComplete = false;
            
            // Posiciona jogador
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.health = player.maxHealth;
            
            // Gera mapa do n√≠vel
            generateLevelMap(levelIndex);
            
            // Spawna inimigos do n√≠vel
            level.enemies.forEach(enemyData => {
                const enemy = new Enemy(enemyData.x, enemyData.y, enemyData.type || 'janis');
                enemies.push(enemy);
            });
            
            // Mostra mensagem do n√≠vel
            console.log(`üéÆ ${level.message}`);
        }

        // Spawn de inimigos melhorado (s√≥ em n√≠veis espec√≠ficos)
        function spawnEnemy() {
            // S√≥ spawna automaticamente ap√≥s n√≠vel 2
            if (game.currentLevel < 2) return;
            
            const spawnPoints = [];
            
            // Encontra pontos v√°lidos de spawn
            for (let i = 0; i < 4; i++) {
                let x, y;
                const side = i;
                
                switch(side) {
                    case 0: x = Math.random() * canvas.width; y = 40; break;
                    case 1: x = canvas.width - 40; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height - 40; break;
                    case 3: x = 40; y = Math.random() * canvas.height; break;
                }
                
                spawnPoints.push({ x, y });
            }
            
            // Escolhe o ponto mais distante do jogador
            let bestPoint = spawnPoints[0];
            let maxDist = 0;
            
            spawnPoints.forEach(point => {
                const dist = Math.sqrt(Math.pow(point.x - player.x, 2) + Math.pow(point.y - player.y, 2));
                if (dist > maxDist) {
                    maxDist = dist;
                    bestPoint = point;
                }
            });
            
            enemies.push(new Enemy(bestPoint.x, bestPoint.y, Math.random() > 0.5 ? 'janis' : 'janis2'));
            createParticles(bestPoint.x, bestPoint.y, colors.neonPurple, 10, 5);
        }

        // Controles
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'r' && game.over) {
                resetGame();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Ajusta posi√ß√£o do mouse com a c√¢mera
            mouse.x = e.clientX - rect.left + game.camera.x;
            mouse.y = e.clientY - rect.top + game.camera.y;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.pressed = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.pressed = false;
        });

        // Reset do jogo
        function resetGame() {
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.trail = [];
            player.currentAction = 'idle';
            game.score = 0;
            game.combo = 1;
            game.over = false;
            game.screenShake = 0;
            game.deathRotation = 0;
            game.deathRotationSpeed = 0.05;
            enemies.length = 0;
            projectiles.length = 0;
            particles.length = 0;
            corpses.length = 0;
            game.bloodParticles.length = 0;
            document.getElementById('gameOver').style.display = 'none';
        }

        // Game loop
        function update() {
            if (game.over) return;
            
            game.time++;

            // Movimento do jogador com colis√£o
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -1;
            if (keys['s'] || keys['arrowdown']) dy = 1;
            if (keys['a'] || keys['arrowleft']) dx = -1;
            if (keys['d'] || keys['arrowright']) dx = 1;
            
            // Atualiza dire√ß√£o baseada no movimento
            if (dx > 0) player.direction = 0;      // Direita
            else if (dy > 0) player.direction = 1; // Baixo
            else if (dx < 0) player.direction = 2; // Esquerda
            else if (dy < 0) player.direction = 3; // Cima
            
            // Normaliza movimento diagonal
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }
            
            // Verifica se est√° se movendo
            player.isMoving = (dx !== 0 || dy !== 0);
            
            // Define a√ß√£o atual
            if (player.health <= 0) {
                player.currentAction = 'death';
            } else if (player.isMoving) {
                player.currentAction = 'ride';
            } else {
                player.currentAction = 'idle';
            }
            
            // Dash (Space) - Usa sprite de wheelie para atropelar
            let currentSpeed = player.speed;
            if (keys[' '] && player.dashCooldown <= 0 && player.onBike) {
                currentSpeed = player.dashSpeed;
                player.dashCooldown = 30;
                player.currentAction = 'wheelie'; // FOR√áA anima√ß√£o de wheelie
                createParticles(player.x, player.y, colors.neonBlue, 10, 5);
                
                // Efeito visual do dash
                game.screenShake = 5;
                
                // Atropela inimigos durante dash
                enemies.forEach((enemy, index) => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.size + player.size + 10) {
                        enemy.health = 0;
                        corpses.push({
                            x: enemy.x,
                            y: enemy.y,
                            angle: enemy.angle,
                            size: enemy.size,
                            color: enemy.color
                        });
                        enemies.splice(index, 1);
                        game.score += 200 * game.combo;
                        game.combo = Math.min(game.combo + 1, 10);
                        game.comboTimer = 120;
                        createBloodSplatter(enemy.x, enemy.y, 30);
                        createParticles(enemy.x, enemy.y, colors.neonPink, 30, 12);
                        game.screenShake = 15;
                    }
                });
            }
            
            // Movimento com verifica√ß√£o de colis√£o
            const nextX = player.x + dx * currentSpeed;
            const nextY = player.y + dy * currentSpeed;
            
            if (!checkWallCollision(nextX, player.y, player.size)) {
                player.x = nextX;
            }
            if (!checkWallCollision(player.x, nextY, player.size)) {
                player.y = nextY;
            }
            
            if (player.dashCooldown > 0) {
                player.dashCooldown--;
                // Mant√©m sprite de wheelie durante o dash
                if (player.dashCooldown > 20) {
                    player.currentAction = 'wheelie';
                }
            }

            // Trail do jogador
            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                player.trail.push({ 
                    x: player.x, 
                    y: player.y,
                    angle: player.angle
                });
                if (player.trail.length > 10) {
                    player.trail.shift();
                }
            }

            // √Çngulo do jogador
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

            // Limites do mundo (n√£o da tela)
            player.x = Math.max(player.size, Math.min(worldWidth - player.size, player.x));
            player.y = Math.max(player.size, Math.min(worldHeight - player.size, player.y));

            // Anima√ß√£o de pedalar
            if (player.currentAction === 'ride' && player.isMoving) {
                player.animTimer++;
                if (player.animTimer > 6) {  // Velocidade da pedalada ajustada
                    player.animTimer = 0;
                    player.animFrame = (player.animFrame + 1) % 2;  // Alterna entre 0 e 1
                }
            } else {
                player.animFrame = 0;
                player.animTimer = 0;
            }
            
            // Ataque
            if (mouse.pressed && player.attackCooldown <= 0) {
                projectiles.push(new Projectile(player.x, player.y, player.angle));
                player.attackCooldown = 8;
                game.screenShake = 3;
                
                // Recuo
                player.x -= Math.cos(player.angle) * 3;
                player.y -= Math.sin(player.angle) * 3;
            }
            
            if (player.attackCooldown > 0) player.attackCooldown--;
            if (player.invulnerable > 0) player.invulnerable--;

            // Combo timer
            if (game.comboTimer > 0) {
                game.comboTimer--;
            } else {
                game.combo = 1;
            }

            // Screen shake decay
            if (game.screenShake > 0) game.screenShake *= 0.9;

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.update());

            // Atualiza proj√©teis
            projectiles.forEach((projectile, index) => {
                if (projectile.update()) {
                    projectiles.splice(index, 1);
                }
            });

            // Atualiza part√≠culas
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Verifica se chegou na sa√≠da do n√≠vel
            const level = levels[game.currentLevel];
            if (level && level.exit) {
                const exitDx = player.x - level.exit.x;
                const exitDy = player.y - level.exit.y;
                
                if (Math.abs(exitDx) < level.exit.width/2 && 
                    Math.abs(exitDy) < level.exit.height/2 &&
                    enemies.length === 0) {  // S√≥ pode sair se matou todos
                    
                    // Pr√≥ximo n√≠vel!
                    game.currentLevel++;
                    if (game.currentLevel < levels.length) {
                        loadLevel(game.currentLevel);
                        createParticles(player.x, player.y, colors.neonBlue, 30, 10);
                    } else {
                        // Vit√≥ria! (por enquanto volta pro in√≠cio)
                        game.currentLevel = 0;
                        loadLevel(0);
                    }
                }
            }
            
            // Spawn de inimigos (aumenta com o tempo)
            const spawnRate = game.currentLevel > 1 ? Math.min(0.02 + (game.time / 10000), 0.05) : 0;
            if (Math.random() < spawnRate) {
                spawnEnemy();
            }

            // Game over com ROTA√á√ÉO dram√°tica
            if (player.health <= 0 && !game.over) {
                game.over = true;
                player.currentAction = 'death';
                // Define ponto focal na posi√ß√£o da morte
                game.cameraX = player.x;
                game.cameraY = player.y;
                // Cria explos√£o de part√≠culas na morte
                createBloodSplatter(player.x, player.y, 50);
                createParticles(player.x, player.y, colors.enemy, 30, 15);
                game.screenShake = 20;
                
                // Inicia rota√ß√£o
                game.deathRotation = 0;
                console.log('MORTE! Iniciando rota√ß√£o');
                
                // Delay para mostrar game over
                setTimeout(() => {
                    document.getElementById('gameOver').style.display = 'block';
                }, 2000);
            }
            
            // Anima rota√ß√£o da morte
            if (game.over) {
                game.deathRotation += game.deathRotationSpeed;
                // Desacelera a rota√ß√£o
                if (game.deathRotationSpeed > 0.001) {
                    game.deathRotationSpeed *= 0.98;
                }
            }

            // Atualiza UI ap√≥s desenhar barra
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('score').textContent = game.score;
            document.getElementById('combo').textContent = game.combo;
        }

        function draw() {
            // Salva estado do canvas
            ctx.save();
            
            // ROTA√á√ÉO DRAM√ÅTICA NA MORTE
            if (game.over) {
                // Rotaciona em torno do centro da tela
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.rotate(game.deathRotation);
                ctx.translate(-canvas.width/2, -canvas.height/2);
            }
            
            // Aplica c√¢mera (translada o mundo)
            ctx.save();
            ctx.translate(-game.camera.x, -game.camera.y);
            
            // Screen shake (aplicado ap√≥s c√¢mera)
            if (game.screenShake > 1) {
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }

            // Limpa apenas a √°rea vis√≠vel
            ctx.fillStyle = colors.floor;
            ctx.fillRect(game.camera.x, game.camera.y, game.camera.width, game.camera.height);

            // Padr√£o de asfalto (apenas √°rea vis√≠vel)
            const startX = Math.floor(game.camera.x / tileSize) * tileSize;
            const endX = Math.ceil((game.camera.x + game.camera.width) / tileSize) * tileSize;
            const startY = Math.floor(game.camera.y / tileSize) * tileSize;
            const endY = Math.ceil((game.camera.y + game.camera.height) / tileSize) * tileSize;
            
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            for (let x = startX; x < endX; x += tileSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
            for (let y = startY; y < endY; y += tileSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
            
            // Marca√ß√µes de asfalto (faixas)
            ctx.strokeStyle = '#444';
            ctx.setLineDash([20, 10]);
            ctx.lineWidth = 3;
            for (let x = 480; x < worldWidth; x += 480) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, worldHeight);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Sangue no ch√£o
            ctx.globalAlpha = 0.7;
            game.bloodParticles.forEach(blood => {
                ctx.fillStyle = blood.color;
                ctx.beginPath();
                ctx.arc(blood.x, blood.y, blood.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Desenha mapa/paredes (apenas vis√≠veis)
            ctx.shadowBlur = 10;
            ctx.shadowColor = colors.neonPurple;
            
            const startTileX = Math.floor(game.camera.x / tileSize);
            const endTileX = Math.ceil((game.camera.x + game.camera.width) / tileSize);
            const startTileY = Math.floor(game.camera.y / tileSize);
            const endTileY = Math.ceil((game.camera.y + game.camera.height) / tileSize);
            
            for (let y = startTileY; y < endTileY && y < map.length; y++) {
                for (let x = startTileX; x < endTileX && x < map[y].length; x++) {
                    if (map[y] && map[y][x] === 1) {
                        ctx.fillStyle = colors.wall;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                        
                        // Borda neon
                        ctx.strokeStyle = colors.neonPurple;
                        ctx.strokeRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            }
            ctx.shadowBlur = 0;

            // Desenha corpos
            ctx.globalAlpha = 0.5;
            corpses.forEach(corpse => {
                ctx.save();
                ctx.translate(corpse.x, corpse.y);
                ctx.rotate(corpse.angle + Math.PI / 2);
                ctx.fillStyle = '#330011';
                ctx.fillRect(-corpse.size/2, -corpse.size/2, corpse.size, corpse.size);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha part√≠culas
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = particle.color;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Desenha inimigos
            enemies.forEach(enemy => enemy.draw());

            // Desenha proj√©teis
            projectiles.forEach(projectile => projectile.draw());

            // Desenha trail do jogador
            player.trail.forEach((point, index) => {
                ctx.globalAlpha = index / player.trail.length * 0.5;
                ctx.fillStyle = colors.player;
                ctx.save();
                ctx.translate(point.x, point.y);
                ctx.rotate(point.angle);
                ctx.fillRect(-player.size/3, -player.size/3, player.size/1.5, player.size/1.5);
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Desenha jogador
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Rota√ß√£o suave para a mira (s√≥ visual, n√£o afeta o sprite)
            const displayAngle = player.angle;
            
            // Pisca quando invulner√°vel
            if (player.invulnerable % 10 < 5) {
                // Se tem sprite do Mad Max, usa sprite
                if (sprites.loaded && sprites.player[player.currentAction]) {
                    const spriteArray = sprites.player[player.currentAction];
                    let sprite;
                    
                    // Se est√° pedalando, alterna entre frames
                    if (player.currentAction === 'ride' && player.isMoving) {
                        // Calcula √≠ndice: dire√ß√£o * 2 + frame de anima√ß√£o
                        const frameIndex = player.direction * 2 + player.animFrame;
                        sprite = spriteArray[frameIndex];
                    } else {
                        // Para outras a√ß√µes, usa √≠ndice direto pela dire√ß√£o
                        sprite = spriteArray[player.direction];
                    }
                    
                    if (sprite && sprite.complete) {
                        // Desenha o sprite do Mad Max
                        ctx.drawImage(
                            sprite,
                            -32, -32,  // Centraliza o sprite de 64x64
                            64, 64
                        );
                    }
                } else {
                    // Fallback para desenho procedural
                    ctx.rotate(displayAngle);
                    
                    // Glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = player.color;
                    
                    // Corpo do jogador (design cyberpunk)
                    ctx.fillStyle = player.color;
                    ctx.beginPath();
                    ctx.moveTo(player.size/2, 0);
                    ctx.lineTo(-player.size/3, -player.size/3);
                    ctx.lineTo(-player.size/2, 0);
                    ctx.lineTo(-player.size/3, player.size/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhe central
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-2, -2, 8, 4);
                }
                
                // N√ÉO desenha linha de mira no player quando tem sprite
            }
            
            ctx.restore();
            
            // Efeito de scanlines

            // Desenha sa√≠da do n√≠vel
            const level = levels[game.currentLevel];
            if (level && level.exit && enemies.length === 0) {  // S√≥ mostra se matou todos
                ctx.save();
                ctx.fillStyle = colors.neonBlue;
                ctx.strokeStyle = colors.neonBlue;
                ctx.shadowBlur = 20;
                ctx.shadowColor = colors.neonBlue;
                ctx.lineWidth = 3;
                
                // Desenha portal de sa√≠da
                ctx.strokeRect(
                    level.exit.x - level.exit.width/2,
                    level.exit.y - level.exit.height/2,
                    level.exit.width,
                    level.exit.height
                );
                
                // Efeito pulsante
                ctx.globalAlpha = Math.sin(game.time * 0.05) * 0.3 + 0.3;
                ctx.fillRect(
                    level.exit.x - level.exit.width/2,
                    level.exit.y - level.exit.height/2,
                    level.exit.width,
                    level.exit.height
                );
                
                ctx.restore();
            }
            
            // UI do n√≠vel
            if (level) {
                ctx.fillStyle = colors.neonPurple;
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'right';
                ctx.fillText(`N√çVEL ${game.currentLevel + 1}: ${level.name}`, canvas.width - 20, 40);
                
            // UI de vida simplificada com cora√ß√µes
            const fullHearts = '‚ù§Ô∏è'.repeat(player.health);
            const emptyHearts = 'üñ§'.repeat(3 - player.health);
            ctx.save();
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(fullHearts + emptyHearts, 20, 50);
            ctx.restore();
                
                // Mensagem se precisa matar inimigos
                if (level.exit && enemies.length > 0) {
                    ctx.fillStyle = colors.enemy;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ELIMINE ${enemies.length} INIMIGO${enemies.length > 1 ? 'S' : ''}`, canvas.width/2, 60);
                }
            }
            
            // Efeito de scanlines
            ctx.restore(); // Volta pro espa√ßo da tela (sem c√¢mera)
            
            ctx.globalAlpha = 0.05;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            ctx.globalAlpha = 1;

            // Vinheta
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // UI (sempre vis√≠vel, n√£o afetada pela c√¢mera)
            // UI de vida simplificada com cora√ß√µes
            const fullHearts = '‚ù§Ô∏è'.repeat(player.health);
            const emptyHearts = 'üñ§'.repeat(3 - player.health);
            ctx.save();
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(fullHearts + emptyHearts, 20, 50);
            ctx.restore();
            
            // UI do n√≠vel
            if (levels[game.currentLevel]) {
                const level = levels[game.currentLevel];
                ctx.fillStyle = colors.neonPurple;
                ctx.font = 'bold 16px Orbitron';
                ctx.textAlign = 'right';
                ctx.fillText(`N√çVEL ${game.currentLevel + 1}: ${level.name}`, canvas.width - 20, 40);
                
                // Mensagem se precisa matar inimigos
                if (level.exit && enemies.length > 0) {
                    ctx.fillStyle = colors.enemy;
                    ctx.textAlign = 'center';
                    ctx.fillText(`ELIMINE ${enemies.length} INIMIGO${enemies.length > 1 ? 'S' : ''}`, canvas.width/2, 60);
                }
            }
            
            // Minimapa
            const minimapWidth = 200;
            const minimapHeight = 60;
            const minimapX = canvas.width - minimapWidth - 20;
            const minimapY = canvas.height - minimapHeight - 20;
            
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(minimapX, minimapY, minimapWidth, minimapHeight);
            ctx.strokeStyle = colors.neonBlue;
            ctx.strokeRect(minimapX, minimapY, minimapWidth, minimapHeight);
            
            // Player no minimapa
            const miniPlayerX = minimapX + (player.x / worldWidth) * minimapWidth;
            const miniPlayerY = minimapY + (player.y / worldHeight) * minimapHeight;
            ctx.fillStyle = colors.player;
            ctx.fillRect(miniPlayerX - 2, miniPlayerY - 2, 4, 4);
            
            // Inimigos no minimapa
            ctx.fillStyle = colors.enemy;
            enemies.forEach(enemy => {
                const miniEnemyX = minimapX + (enemy.x / worldWidth) * minimapWidth;
                const miniEnemyY = minimapY + (enemy.y / worldHeight) * minimapHeight;
                ctx.fillRect(miniEnemyX - 1, miniEnemyY - 1, 2, 2);
            });

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Inicializa o jogo
        loadLevel(0);
        gameLoop();
    </script>
</body>
</html>
